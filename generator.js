/**
 *
 * @source: generator.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in this page.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in this page.
 *
 */

// Variable object is the representation of a variable
// as it is parsed and generated by s2sc
function Variable (Vname, Vtype, Vline, Vambiguous, Vtemp) {


	if (typeof(Vambiguous) === "undefined") {
		Vambiguous = false;
	}

	if (typeof(Vtemp) === "undefined") {
		Vtemp = false;
	}

	this.name = Vname;
	this.type = Vtype;
	this.lineDeclared = Vline;
	this.ambiguous = Vambiguous;
	this.temporary = Vtemp;
}

// This holds information about what type of statement it holds
// and the state of the variables during that line.
function Action (Atype) {

	this.type = Atype;
	this.state = [];

	this.pushVariableState = function(variable) {

		var found = false;

		for (var i = 0; i < this.state.length; i++) {

			if (variable.name == this.state[i].name) {
				found = true;
			}
		}

		if (!found) {
			this.state.push(clone.variable(variable));
		}
	}
}

// Stack data type that is used when the generator
// detects a usage of a function.
function ParenthesisStack (Svariable) {

	this.count = 0
	this.set = 0;
	this.functionName = new Array();
	this.content = new Array();

	this.pushData = function(data) {
		if (this.content.length == 0) {
			throw "Invalid Operation";
		}

		this.content[this.content.length - 1].data.push(data);
	}
}

// Keeps in track of a stack content of a parenthesis stack.
function StackContent () {

	this.data = [];
	this.result = "";
}

// The representation of a line of code
function Line (Lline, Ltoks, Lval, LtokIDs) {

	this.clauseStatement = false;
	this.comment = false;
    this.length = Ltoks.length;
	this.lineNumber = Lline;
	this.tokens = Ltoks;
	this.values = Lval;
	this.id = LtokIDs;

	this.actionStack = [];
	this.contentStack = [];
}

// Is used by the generator for languages
// that allows a way to group a set of variables
// and functions (classes or structs)
function Structure (Sname, Scontent) {

	this.name = Sname;
	this.content = Scontent;
}

// Function representation
function Func (Fname, Fparam, Ftype, Fcontent) {

	this.name = Fname;
	this.param = Fparam;
	this.type = Ftype;
	this.content = Fcontent;
}


// Temporary Variable State Object used by
// generator.generateCode()'s tmpVariableStack
// variable
function tmpVariableState (TrefactorIndex) {

    this.referenceIndex  = TrefactorIndex;
}

// Definition Holder Object used by
// generator.generateCode()'s definitionStack
// variable
function tmpDefinitionState (TfuncName, TfuncArgs, TfuncIndention, TfuncLines, Ttype, Tvariables) {

	var _variables = null;
	if (typeof(Tvariables) === "undefined") {
		_variables = new Array();
	}
	else {
		_variables = Tvariables;
	}

    this.name = TfuncName;
    this.arguments = TfuncArgs;
    this.indention = TfuncIndention; // Used for determining indention level
                                     // in order to know if a particular statement
                                     // still belongs to a function/loop/structure
                                     // in python
    this.contains  = TfuncLines;
    this.definitionType = Ttype;
    this.variables = _variables;
    this.original = new Array();

    this._varList = new Array();
}

// Parsed Data that that is consolidated
// to a single object.
function ParseData (Pmap, Psymbol) {

	this.map = Pmap;
	this.symbol = Psymbol;
}

//////////////////////////////////////////////////////////////////////////
// Generator class														//
//////////////////////////////////////////////////////////////////////////
/*																		/*
	Is the class that is responsible for s2sc's code generation, it uses
	the results that was given out by the tokenizer (for identifying
	which set of words matches a specific token type), parser (for
	knowing the objective of a statement) and dictionary (which holds
	information about the list of functions that is possibily used by
	a programming language.
/************************************************************************/
var generator = {

	// Namespace that holds the static keywords of a
	// language, this is done to make it as verbose as possible.
	enums: {

		definition: {

			function: "function",
			condition: "condition",
			loop: "loop",
		},

		c: {

			data: {

				type: {

					integer: "int",
					float: "float",
					bool: "bool",
					string: "string",
					object: "object",
					void: 0,

					pointer: {

                        integer: "int *",
                        float: "float *",
                        bool: "bool *",
                        void: "void *",
                        object: "void *",
					},

					array: {

                        integer: "intContainer",
                        float: "floatContainer",
                        bool: "boolContainer",
                        object: "objectContainer",
                        string: "stringContainer",
					},
				}
			},

			symbol: {

				string: "char *",
				true: "true",
				false: "false",
				not: "!",
				or: "||",
				and: "&&",
				startComment: "/*",
				endComment: "*/",
				oneLineComment: "//",
			},

			action: {

				return: {

					undefined: "returnUndefined",
					string: "returnString",
					constant: "returnConst",
				},
			},
		},

		error: {

			parse: "<parse_error>"
		},

		python: {

			data: {

				type: {

					integer: "int",
					float: "float",
					bool: "bool",
					string: "string",
					object: "object",
					void: 0
				},

				structure: {

					list: "list"
				}
			},

			symbol: {

				string: "str",
				exponent: "**",
				floorDivision: "//",
				true: "True",
				false: "False",
				not: "not",
				and: "and",
				or: "or"
			}
		},


		action: {

			basic: {

				constant: "const",
				stringConstant: "sConst",
				result: "result",
				id: "id",
				increment: "incr",
				boolean: "boolStmt",
				array: "array",
			},

			return: {

				void: "returnUndefined",
				constant: "returnConst",
				string: "returnString"
			},

            declaration: "decl",
            functionDefinition: "funcDef",
            stringDeclaration: "strDecl",
            arrayAssignment: "arrayAsgn",
            compoundAssignment: "cmpAsgn",
            booleanDeclaration: "boolDecl",
            conditionStatement: "condStmt",
            conditionStatementClosure: "condStmtClosure",
            loopStatement: "loopStmt",
            loopStatementClosure: "loopStmtClosure",
            import: "actionImport",
        },

        shared: {

			c_python: {

				return: "return",
			}
        },

        symbol: {

			add: "+",
			subtract: "-",
			multiply: "*",
			divide: "/",
			dot: ".",
			comma: ",",
			equal: "=",
			openCurlBrace: "{",
			closeCurlBrace: "}",
			leftParenthesis: "(",
			rightParenthesis: ")",
			openBracket: "[",
			closeBracket: "]",
			lessThan: "<",
			greaterThan: ">",
			true: "True",
			false: "False",
			colon: ":"

        },

		token: {

			keyword: "kwd",
			identifier: "id",
			symbol: "symb",
			constant: "const",
			reserveWord: "res",
			stringConstant: "sConst",
			tab: "tab",
			comment: "cmnt",
		}


	},

	// Namespace that holds functions related to including specific built in function,
	// data types and even the necessary modules (headers, sub-classes) that is needed
	// to be imported by a function.
	includer: {

		dataType: {

			ambiguous: function() {

				generator.headers.insert("stdbool.h");
				generator.unions.insert("ambiguous", "\tbool *boolValue;\n\tint *intValue;\n\tfloat *floatValue;\n\tdouble *doubleValue;\n\tchar *charValue;\n\tvoid *voidValue;\n");
			}
		},

		function: {

			parser: {

				float: {

					string: function() {

						generator.headers.insert("stdio.h");

						if (generator.options.useDoubleInsteadOfFloat) {
							generator.functions.insert("toDouble_str",
								"\tdouble variable = 0;\n\tsscanf(str, \"%d\", &variable);\n\treturn variable;\n",
								"double", "const char *str"
							);
						}
						else {
							generator.functions.insert("toFloat_str",
								"\tfloat variable = 0;\n\tsscanf(str, \"%d\", &variable);\n\treturn variable;\n",
								"float", "const char *str"
							);
						}
					}
				},

				integer: {

					string: function() {

						generator.headers.insert("stdio.h");
						generator.functions.insert("toInteger_str",
							"\tint variable = 0;\n\tsscanf(str, \"%d\", &variable);\n\treturn variable;\n",
							"int", "const char *str"
						);
					}
				},

				string: {

					integer: function() {

						generator.headers.insert("stdio.h");
						generator.headers.insert("stdlib.h");
						generator.includer.function.memory.gc();
						generator.functions.insert("toString_int",
							"\tchar *buffer = (char*)calloc(2048, sizeof(char));\n\tsprintf(buffer, \"%d\", num);\n\treturn buffer;\n",
							"char *", "int num"
						);
					},

					float: function() {

						generator.headers.insert("stdio.h");
						generator.headers.insert("stdlib.h");
						generator.includer.function.memory.gc();
						if (generator.options.useDoubleInsteadOfFloat) {
							generator.functions.insert("toString_double",
								"\tchar *buffer = (char*)calloc(2048, sizeof(char));\n\tsprintf(buffer, \"%f\", num);\n\treturn buffer;\n",
								"char *", "double num"
							);
						}
						else {
							generator.functions.insert("toString_float",
								"\tchar *buffer = (char*)calloc(2048, sizeof(char));\n\tsprintf(buffer, \"%f\", num);\n\treturn buffer;\n",
								"char *", "float num"
							);

						}
					},

					concatenator: function() {

						generator.headers.insert("stdio.h");
						generator.headers.insert("stdlib.h");
						generator.headers.insert("stdarg.h");
						generator.headers.insert("string.h");
						generator.includer.function.memory.gc();
						generator.functions.insert("strConcat",
							"\tchar *buffer = (char*)calloc(2048, sizeof(char));\n\tstrcpy(buffer, \"\");\n\n\tva_list vl;\n\tva_start(vl, limit);\n\tfor (int i = 0; i < limit; i++) {\n\t\tstrcat(buffer, va_arg(vl, char*));\n\t}\n\tva_end(vl);\n\treturn buffer;\n",
							"char *", "int limit, ..."
						);
					}
				}
			},

			math: {

				pow: function() {
					generator.headers.insert("tgmath.h");
				}
			},

			loop: {

				range: function() {
					generator.headers.insert("stdlib.h");
				}
			},

			memory: {

				gc: function() {

					generator.headers.insert("gc.h");
					generator.defines.insert("malloc(n)", "GC_MALLOC(n)");
					generator.defines.insert("calloc(m,n)", "GC_MALLOC(m*n)");
					generator.defines.insert("free(p)", "GC_FREE(p)");
					generator.defines.insert("realloc(n)", "GC_REALLOC(n)");
				}
			},
		}
	},

	// Namespace that contains the global variables used by s2sc
	variables: {

		comment : '/*******************************************************\n\
\t\tCode generated by s2sc.js\n\
*******************************************************/\n\n',
		defineString: "",
		headerString : "",
		struct: "",
		union: "",
		functions: "",
		bodyBegin : "int main ( void ) {\n\n",
		bodyEnd   : "\treturn 0;\n}",
	},

	// C related name aliasing
	defines: {

		list: Array(),

		insert: function(name, content) {

			var found = false;
			var struct = new Structure(name, content);
			for (var i = 0; i < generator.defines.list.length; i++) {

				if (generator.defines.list[i].name == struct.name) {
					found = true;
				}
			}

			if (!found) {
				generator.defines.list.push(struct);
			}
		},

		clear: function() {

			generator.variables.defineString = "";
			generator.defines.list = new Array();
		}
	},

	// Holds the list of headers during code generation
	headers: {

		list: Array(),

		insert: function(value) {

			var found = false;
			for (var i = 0; i < generator.headers.list.length; i++) {

				if (generator.headers.list[i] == value) {
					found = true;
				}
			}

			if (!found) {
				generator.headers.list.push(value);
			}
		},

		clear: function() {

			generator.variables.headerString = "";
			generator.headers.list = new Array();
		}
	},

	// Holds the list of C related structures during code generation
	structures: {

		list: Array(),
		insert: function(name, content) {

			var found = false;
			var struct = new Structure(name, content);
			for (var i = 0; i < generator.structures.list.length; i++) {

				if (generator.structures.list[i].name == struct.name) {
					found = true;
				}
			}

			if (!found) {
				generator.structures.list.push(struct);
			}
		},
		clear: function() {

			generator.variables.struct = "";
			generator.structures.list = new Array();
		}
	},

	// Holds the list of C related union during code generation
	unions: {

		list: Array(),
		insert: function(name, content) {

			var found = false;
			var struct = new Structure(name, content);
			for (var i = 0; i < generator.unions.list.length; i++) {

				if (generator.unions.list[i].name == struct.name) {
					found = true;
				}
			}

			if (!found) {
				generator.unions.list.push(struct);
			}
		},

		clear: function() {

			generator.variables.union = "";
			generator.unions.list = new Array();
		}
	},

	// Holds the list of C related functions during code generation
	functions: {

		list: Array(),

		insert: function(name, content, type, parameter) {

			var found = false;
			var struct = new Func(name, parameter, type, content);
			for (var i = 0; i < generator.functions.list.length; i++) {

				if (generator.functions.list[i].name == struct.name) {
					found = true;
				}
			}

			if (!found) {
				generator.functions.list.push(struct);
			}
		},

		search: function(name) {

            var list = generator.functions.list;
            for (var i = 0; i < list.length; i++) {

                if (list[i].name == name) {
                    return list[i];
                }
            }

            throw generator.functions.exception.NoFunctionFoundException
		},

		clear: function() {

			generator.variables.functions = "";
			generator.functions.list = new Array();
		},

		exception: {

            NoFunctionFoundException: "Function can't be found on the generator database",
		}
	},

	// Namespaces that holds about code refactoring related materials
	refactor:{

		variableList: [],
		functionList: [],

		typeChangeCount: 0,
		loopCount   : 0,
		paramMDCount: 0, //Counts the number of parameters passed that has to be declared manually
                        //because of data type incompatibility

		findVariable: function (name, debug) {

			if (typeof(debug) === "undefined") {
				debug = false;
			}

			for (var i = 0; i < generator.refactor.variableList.length; i++) {

				if (debug) {
					alert(generator.refactor.variableList[i].name + " ===" + name);
				}

				if (generator.refactor.variableList[i].name == name) {
					return i;
				}
			}

			return -1;
		},

		getVariable: function (name) {

			var index = generator.refactor.findVariable(name);
			if (index != -1) {

				return generator.refactor.variableList[index];
			}

			throw "variable " + name + " is not defined";
		},

		insertVariable: function (variable) {

            variable = clone.variable(variable);
			var found = generator.refactor.findVariable(variable.name);
			if (found == -1) {
				generator.refactor.variableList.push(variable);
			}
		},

		removeVariable: function (name) {

			var index = generator.refactor.findVariable(name);
			if (index != -1) {
				generator.refactor.variableList.splice(index, 1);
			}
		},

		clear: function () {

			generator.refactor.variableList = new Array();
		},

		findFunction: function (name) {

			for (var i = 0; i < generator.refactor.functionList.length; i++) {

				if (generator.refactor.functionList[i].name == name) {
					return i;
				}
			}

			return -1;
		},

		getFunction: function(name) {

			var index = generator.refactor.findFunction(name);
			if (index != -1) {

				return generator.refactor.functionList[index];
			}

			throw "Not found function(" + name + ") on refactor list";
		},
	},

	c: {

		to: {

			python: {

				refactor: function (variable, buffer) {

					if (generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type === 0 && generator.refactor.variableList[generator.refactor.findVariable(variable.name)].temporary) {

						variable.type = generator.enums.c.data.type.integer;
						generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type = generator.enums.c.data.type.integer;
						generator.refactor.variableList[generator.refactor.findVariable(variable.name)] = true;
					}
					
					if (variable.ambiguous == false) {
						var foundDeclarationLine = false;
						try {
							if (variable.type != generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type) {

								for (var i = 0; i < buffer.length; i++) {

									var tmpVariableHolder = null;
									var foundDecl =  null;

									for (var j = 0; j < buffer[i].actionStack.length; j++) {

										for (var k = 0; k < buffer[i].actionStack[j].state.length; k++) {

											if (buffer[i].actionStack[j].state[k].name == variable.name) {
												tmpVariableHolder = clone.variable(buffer[i].actionStack[j].state[k]);
												foundDecl = buffer[i].actionStack[j].type;
											}
										}
									}

									if (foundDeclarationLine == false && tmpVariableHolder != null) {

										for (var j = 0; j < buffer[i].values.length; j++) {

											if (buffer[i].values[j] == variable.name) {

												var content = "";
												var allocContent = "";
												foundDeclarationLine = true;

												if (tmpVariableHolder.type == generator.enums.c.data.type.string) {
													buffer[i].contentStack.shift();
												}
												else {
													buffer[i].contentStack[0] = buffer[i].contentStack[0].replace(tmpVariableHolder.type + " ", "");
												}

												if (tmpVariableHolder.type == generator.enums.c.data.type.string) {

													content += tmpVariableHolder.name + ".charValue";
													allocContent = "( char * ) calloc(2048, sizeof( char ) )";
												}
												else {

													content += tmpVariableHolder.name + "." + tmpVariableHolder.type + "Value";
													allocContent = "( " + tmpVariableHolder.type + " * ) calloc(1, sizeof( " + tmpVariableHolder.type + " ) )";
												}

												for (var k = 0; k < buffer[i].tokens.length; k++) {

													if (buffer[i].tokens[k] == generator.enums.token.stringConstant) {
														buffer[i].contentStack[0] = buffer[i].contentStack[0].replace(buffer[i].values[k], buffer[i].id[k]);
													}
												}

												if (tmpVariableHolder.type == generator.enums.c.data.type.string) {
													buffer[i].contentStack[0] = buffer[i].contentStack[0].replace(RegExp('\\b' + tmpVariableHolder.name + '\\b','g'), "(" + content + ")");
												}
												else {
													buffer[i].contentStack[0] = buffer[i].contentStack[0].replace(RegExp('\\b' + tmpVariableHolder.name + '\\b','g'), "(*" + content + ")");
												}

												for (var k = 0; k < buffer[i].tokens.length; k++) {

													if (buffer[i].tokens[k] == generator.enums.token.stringConstant) {
														buffer[i].contentStack[0] = buffer[i].contentStack[0].replace(buffer[i].id[k], buffer[i].values[k]);
													}
												}

												buffer[i].contentStack.unshift(content + " = " + allocContent);
												buffer[i].contentStack.unshift("ambiguous " + variable.name);
												continue;
											}
										}
									}
									else if (tmpVariableHolder != null) {

										for (var j = 0; j < buffer[i].contentStack.length; j++) {

											var content = "";
											var currentLine = buffer[i].contentStack[j];

											if (tmpVariableHolder.type == generator.enums.c.data.type.string) {

												content += tmpVariableHolder.name + ".charValue";
											}
											else {

												content += "(*" + tmpVariableHolder.name + "." + tmpVariableHolder.type + "Value)";
											}

											for (var k = 0; k < buffer[i].tokens.length; k++) {

												if (buffer[i].tokens[k] == generator.enums.token.stringConstant) {
													currentLine = currentLine.replace(buffer[i].values[k], buffer[i].id[k]);
												}
											}

											currentLine = currentLine.replace(RegExp('\\b' + tmpVariableHolder.name + '\\b','g'), content);

											for (var k = 0; k < buffer[i].tokens.length; k++) {

												if (buffer[i].tokens[k] == generator.enums.token.stringConstant) {
													currentLine = currentLine.replace(buffer[i].id[k], buffer[i].values[k]);
												}
											}

											buffer[i].contentStack[j] = currentLine;
										}
									}

                                    //alert(buffer[i].contentStack);
								}

								variable.ambiguous = true;
								generator.includer.dataType.ambiguous();
							}
						}
						catch (exception) {

							exception.message = variable.name + " is undefined";
							throw exception;
						}
					}
				},

				processBasicStatement: function (buffer, line, action, legal, definitionStack, currentLanguage, targetLanguage) {


					line = clone.line(line);
					var isStr = action.type == generator.enums.action.basic.stringConstant || action.type == generator.enums.action.return.string ? true : false;
					var contentBuffer = [];
					var lastContent = "";
					var typeCasted = false;
					var numericVariables = 0;
					var checkStack = new ParenthesisStack();
					var resultingDataType = 0;
					var compoundVariableDataType = 0;
					var parameterSeparated = false;
					var override = false;
					var hasReturnType = false;
					var errorDescription = "";

					for (var j = 0; j < line.tokens.length; j++) {

						if (parameterSeparated) {

							if (typeCasted) {
								override = true;
							}
							typeCasted = true;
							isStr = false;
						}

						if (line.tokens[j] == generator.enums.token.identifier) {

							try {

								var tmpVariable =
									generator.refactor.getVariable(line.values[j]);

								if (action.type == generator.enums.action.compoundAssignment &&
									compoundVariableDataType == 0) {
									compoundVariableDataType = tmpVariable.type;
								}

								if (resultingDataType == 0 ||
									resultingDataType != generator.enums.c.data.type.float &&
									resultingDataType != generator.enums.c.data.type.bool) {
									resultingDataType = tmpVariable.type;
								}

								action.pushVariableState(tmpVariable);
								if (tmpVariable.type == generator.enums.c.data.type.integer ||
									tmpVariable.type == generator.enums.c.data.type.float ) {

									if (!typeCasted) {
										numericVariables += 1;
									}
								}
								else if (tmpVariable.type == generator.enums.c.data.type.bool) {

								}
								else {


									if (tmpVariable.type == 0) {
										tmpVariable.type = generator.enums.c.data.type.integer;
									}
									else if (!typeCasted) {

										isStr = true;
									}
								}
							}
							catch (exception) {

								errorDescription = exception;
								legal = false;
							}
						}
						else if (line.tokens[j] == generator.enums.token.constant) {

							try {
								if (resultingDataType != generator.enums.c.data.type.float &&
									resultingDataType != generator.enums.c.data.type.bool) {

									resultingDataType = isEquation(line.values[j]);
								}
							}
							catch (exception) {

								errorDescription = "Illegal usage of constant expression";
								legal = false;
							}

							if (!typeCasted && isStr) {
								numericVariables += 1;
							}
						}
						else if (line.tokens[j] == generator.enums.token.reserveWord) {

							if (line.values[j] == generator.enums.c.data.type.integer ||
								line.values[j] == generator.enums.c.data.type.float ||
								line.values[j] == generator.enums.python.symbol.string) {

								typeCasted = true;
								if (line.values[j] == generator.enums.python.symbol.string) {
									isStr = true;
									resultingDataType = generator.enums.c.data.type.string;
								}
							}
							else if (line.values[j] == generator.enums.python.symbol.true ||
									 line.values[j] == generator.enums.python.symbol.false||
									 line.values[j] == generator.enums.python.symbol.not ||
									 line.values[j] == generator.enums.python.symbol.and ||
									 line.values[j] == generator.enums.python.symbol.or) {

								if (!typeCasted) {
									resultingDataType = generator.enums.c.data.type.bool;
								}
							}
						}
						else if (line.tokens[j] == generator.enums.token.keyword) {

							var keyword = dictionary.pages.findWord(line.values[j], currentLanguage);
							var funcType = keyword.returnType;

							if (funcType == generator.enums.c.data.type.void) {
								errorDescription = "function " + keyword.name + " does not define a data type.";
								legal = false;
							}
							else if (funcType == generator.enums.c.data.type.string && !typeCasted) {
								isStr = true;
								resultingDataType = generator.enums.c.data.type.string;
							}
							else if (funcType == generator.enums.c.data.type.integer ||
									funcType == generator.enums.c.data.type.float) {

								if (!typeCasted && isStr) {
									numericVariables++;
								}
							}

						}
						else if (line.tokens[j] == generator.enums.token.symbol) {

							if (line.values[j] == generator.enums.symbol.leftParenthesis) {

								if (typeCasted) {
									checkStack.set++;
								}
							}
							else if (line.values[j] == generator.enums.symbol.rightParenthesis) {

								if (checkStack.set > 0) {
									checkStack.set--;
								}

								if (checkStack.count == 0) {
									typeCasted = false;
								}

								if (checkStack.set == 0 && checkStack.count > 0) {
									checkStack.count--;
								}
							}
							else if (
								line.values[j] == generator.enums.symbol.subtract ||
								line.values[j] == generator.enums.symbol.multiply ||
								line.values[j] == generator.enums.symbol.divide
							) {

								if (isStr && !typeCasted) {

									legal = false;
								}
							}
							else if (line.values[j] == generator.enums.symbol.comma && !parameterSeparated) {

								parameterSeparated = true;
								continue;
							}
						}
						else if (line.tokens[j] == generator.enums.token.stringConstant) {

							isStr = true;
							if (resultingDataType == 0 || !typeCasted) {
								resultingDataType = generator.enums.c.data.type.string;
							}
						}

						if (parameterSeparated) {

							if (!override) {
								typeCasted = false;
							}
							override = false;
							parameterSeparated = false;
						}
					}

					if (resultingDataType != compoundVariableDataType &&
						action.type == generator.enums.action.compoundAssignment) {

						if ((
							 resultingDataType != generator.enums.c.data.type.integer &&
							 resultingDataType != generator.enums.c.data.type.float &&
							 resultingDataType != generator.enums.c.data.type.bool
							) ||
							(
							 compoundVariableDataType != generator.enums.c.data.type.integer &&
							 compoundVariableDataType != generator.enums.c.data.type.float &&
							 compoundVariableDataType != generator.enums.c.data.type.bool
							)) {
							errorDescription = "incompatible data types";
							legal = false;
						}
					}

					if (isStr && numericVariables > 0) {
						errorDescription = "String and Numeric variables cannot be added directly";
						legal = false;
					}


					if (!isStr && legal) {

						var exponent = false;
						var floor = false;
						var stack = new ParenthesisStack();
						line.actionStack.push(action);

						for (var j = 0; j < line.tokens.length; j++) {

							lastContent = contentBuffer.slice();

							if (line.tokens[j] == generator.enums.token.constant) {

								try {

									var constantValue = "";
									if (!isInteger(line.values[j])) {
										if (generator.options.useDoubleInsteadOfFloat) {
											constantValue += line.values[j];
										}
										else {
											constantValue += line.values[j] + "f";
										}
									}
									else {
										constantValue += line.values[j];
									}

									if (exponent) {
										exponent = false;
										var prevValue = "";
										if (stack.count > 0) {
											prevValue = stack.content[stack.content.length - 1].data.pop();
										}
										else {
											prevValue = contentBuffer.pop();
										}
										var parameter = [prevValue, ",", constantValue];
										var list = dictionary.pages.findWordsByKeywords(["math-operation", "exponent", "C-language"]);
										var candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
										contentBuffer.push(candidate.function(parameter));
									}
									else if (floor) {
										floor = false;
									}
									else {
										contentBuffer.push(constantValue);
									}

								}
								catch (exception) {

									legal = false;
								}
							}
							else if (line.tokens[j] == generator.enums.token.identifier) {


								var identifier = null;
								for (var k = 0; k < line.actionStack.length; k++) {

									for (var l = 0; l < line.actionStack[k].state.length; l++) {

										if (line.values[j] == line.actionStack[k].state[l].name) {

											identifier = line.actionStack[k].state[l];
											break;
										}
									}
								}

								if (identifier != null) {


									if (identifier.ambiguous) {
										if (identifier.type == generator.enums.c.data.type.string) {
											contentBuffer.push(identifier.name + ".charValue");
										}
										else {
											contentBuffer.push("(*" + identifier.name+ "." + identifier.type + "Value)");
										}

									}
									else {
										contentBuffer.push(identifier.name);
									}
								}

							}
							else if (line.tokens[j] == generator.enums.token.reserveWord) {

								if (line.values[j] == generator.enums.c.data.type.integer ||
									line.values[j] == generator.enums.python.data.type.float ||
									line.values[j] == generator.enums.python.symbol.string) {
									if (j + 1 != line.tokens.length) {
										if (line.values[j + 1] == generator.enums.symbol.leftParenthesis) {
											stack.count += 1;
											stack.functionName.push(line.values[j]);
											stack.content.push(new StackContent());
										}
									}
								}
								else if (line.values[j] == generator.enums.python.symbol.true) {
                                    contentBuffer.push(generator.enums.c.symbol.true);
								}
								else if (line.values[j] == generator.enums.python.symbol.false) {
                                    contentBuffer.push(generator.enums.c.symbol.false);
								}
								else if (line.values[j] == generator.enums.python.symbol.not) {
                                    contentBuffer.push(generator.enums.c.symbol.not);
								}
								else if (line.values[j] == generator.enums.python.symbol.and) {
                                    contentBuffer.push(generator.enums.c.symbol.and);
								}
								else if (line.values[j] == generator.enums.python.symbol.or) {
                                    contentBuffer.push(generator.enums.c.symbol.or);
								}
								else if (line.values[j] == generator.enums.shared.c_python.return){

									hasReturnType = true;
									contentBuffer.push(line.values[j]);
								}
							}
							else if (line.tokens[j] == generator.enums.token.stringConstant) {

								contentBuffer.push(line.values[j]);
							}
							else if (line.tokens[j] == generator.enums.token.symbol) {

								var pushToBuffer = false;

								if (line.values[j] == generator.enums.symbol.leftParenthesis) {

									if (stack.count > 0) {
										if (!((line.values[j - 1] == generator.enums.c.data.type.integer ||
											line.values[j - 1] == generator.enums.python.data.type.float ||
											line.values[j - 1] == generator.enums.python.symbol.string) ||
											line.tokens[j - 1] == generator.enums.token.keyword)) {
											pushToBuffer = true;
											stack.set++;
										}
									}
									else {
										pushToBuffer = true;
									}
								}
								else if (line.values[j] == generator.enums.symbol.rightParenthesis) {

									if (stack.set > 0) {
										stack.set--;
									}

									if (stack.count == 0) {
										pushToBuffer = true;
									}

									if (stack.set == 0 && stack.count > 0) {

										stack.count--;
										var currentFunction = stack.functionName.pop();
										var currentContentBuffer = stack.content.pop();

										var tmpEquation = currentContentBuffer.data.slice();

										for (var k = 0; k < tmpEquation.length; k++) {

											if (tmpEquation[k].search("intValue") != -1) {

												tmpEquation[k] = tmpEquation[k].substring(1).replace(RegExp('\\b' + ".intValue" + '\\b','g'), "");
											}
											else if (tmpEquation[k].search("intValue") != -1) {
												tmpEquation[k] = tmpEquation[k].substring(1).replace(RegExp('\\b' + ".floatValue" + '\\b','g'), "");
											}
											else if (tmpEquation[k].search("charValue") != -1) {
												tmpEquation[k] = tmpEquation[k].replace(RegExp('\\b' + ".charValue" + '\\b','g'), "");
											}
										}

										var operationType = isEquation(tmpEquation.join(" "));
										//alert(operationType + "-" + currentFunction + " = " + currentContentBuffer.data.join(" "));
										// To do: Revamp function parameter handling so that it supports ambiguous calls

										if (operationType == generator.enums.c.data.type.string) {

											var list;
											var candidate;
											var result = "";

											if (currentFunction == generator.enums.c.data.type.integer) {

												if (currentContentBuffer.data.length > 1) {
													//alert(currentContentBuffer.data.join(","));
													for (var k = 0; k < currentContentBuffer.data.length; k++) {
														if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
															currentContentBuffer.data.splice(k, 1);
															k--;
														}
													}

													list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
													result = candidate.function(currentContentBuffer.data);

													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.integer, 3);
													result = candidate.function(result);
												}
												else {
													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.integer, 3);
													result = candidate.function(currentContentBuffer.data);
												}
											}
											else if (currentFunction == generator.enums.python.data.type.float) {

												if (currentContentBuffer.data.length > 1) {

													for (var k = 0; k < currentContentBuffer.data.length; k++) {
														if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
															currentContentBuffer.data.splice(k, 1);
															k--;
														}
													}

													list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
													result = candidate.function(currentContentBuffer.data);

													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
													result = candidate.function(result);
												}
												else {
													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
													result = candidate.function(currentContentBuffer.data);
												}

											}
											else if (currentFunction == generator.enums.python.symbol.string) {

												for (var k = 0; k < currentContentBuffer.data.length; k++) {
													if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
														currentContentBuffer.data.splice(k, 1);
														k--;
													}
												}

												list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data);
											}
											else {
												// Function Analyser here
												try {

													var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
													result = candidate.function(currentContentBuffer.data);

												}
												catch (exception) {

													if (exception === dictionary.search.exception.NoEquivalent) {

														try {

                                                            var func = generator.refactor.getFunction(currentFunction);
                                                            var candidate = generator.c.to.python.processUserDefinedFunction(buffer, func, currentContentBuffer.data);


                                                            var parameters = generator.functions.search(candidate.name).param;
                                                            parameters = parameters.split(", ");

                                                            for (var k = 0; k < parameters.length; k++) {

                                                                var bufferParameterType = isEquation(currentContentBuffer.data[k]);
                                                                var currentParameter = parameters[k].split(" ");
                                                                var incompatible = false;

                                                                if (currentParameter[0] == "ambiguous") {
                                                                    if (bufferParameterType != "ambiguous") {
                                                                        incompatible = true;
                                                                    }
                                                                }

                                                                if (incompatible) {

                                                                    generator.refactor.paramMDCount++;
                                                                    var initializeString = ["", "", ""];
                                                                    initializeString[0] = "ambiguous __param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    generator.includer.function.memory.gc();
                                                                    var tmpVar = new Variable("__param__init__" + currentParameter[1] + generator.refactor.paramMDCount, bufferParameterType, i);
                                                                    if (definitionStack.length > 0) {

                                                                        tmpVar.temporary = true;
                                                                        var exist = false;

                                                                        for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

                                                                            if (definitionStack[definitionStack.length - 1].variables[j] == tmpVar.name) {
                                                                                insideParameter = true;
                                                                                exist = true;
                                                                                break;
                                                                            }
                                                                        }

                                                                        if (!exist) {
                                                                            definitionStack[definitionStack.length - 1].variables.push(tmpVar.name);
                                                                        }
                                                                    }

                                                                    generator.refactor.insertVariable(tmpVar);

                                                                    if (bufferParameterType == generator.enums.c.data.type.string) {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue = ";
                                                                        initializeString[1]+= "( char * ) calloc(2048, sizeof( char ) )";
                                                                        initializeString[2]+= "sprintf(__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue, " + currentContentBuffer.data[k] + ")";
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    }
                                                                    else {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType + "Value = ";
                                                                        initializeString[1]+= "( " + bufferParameterType + " * ) calloc(1, sizeof( " + bufferParameterType + " ) )";
                                                                        initializeString[2]+= "(*__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType  + "Value"+ ") = ";
                                                                        initializeString[2]+= currentContentBuffer.data[k];
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    }

                                                                    for (var l = 0; l < 3; l++) {
                                                                        if (stack.content.length == 0) {
                                                                            line.contentStack.push(initializeString[l]);
                                                                        }
                                                                        else {
                                                                            stack.content[stack.content.length - 1].data.push(initializeString[l]);
                                                                        }
                                                                    }
                                                                }
                                                            }

                                                            result = candidate.function(currentContentBuffer.data);
                                                        }
                                                        catch (innerException) {

                                                            throw innerException;
                                                        }
													}
												}
											}
										}
										else if (operationType == generator.enums.c.data.type.integer) {

											var list;
											var candidate;
											var result = "";

											if (currentFunction == generator.enums.c.data.type.integer) {
												result = currentContentBuffer.data.join(" ");
											}
											else if (currentFunction == generator.enums.python.data.type.float) {
												result = "((" + generator.enums.c.data.type.float + ")(" + currentContentBuffer.data.join(" ") + "))";
											}
											else if (currentFunction == generator.enums.python.symbol.string) {
												list = dictionary.pages.findWordsByKeywords(["integer-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data.join(" "));
											}
											else {
												//alert(currentContentBuffer.data.join("-") + currentFunction);
												try {

													var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
													result = candidate.function(currentContentBuffer.data);

												}
												catch (exception) {

													if (exception === dictionary.search.exception.NoEquivalent) {

														try {


															var func = generator.refactor.getFunction(currentFunction);
															var candidate = generator.c.to.python.processUserDefinedFunction(buffer, func, currentContentBuffer.data);


                                                            var parameters = generator.functions.search(candidate.name).param;
                                                            parameters = parameters.split(", ");

                                                            for (var k = 0; k < parameters.length; k++) {

                                                                var bufferParameterType = isEquation(currentContentBuffer.data[k]);
                                                                var currentParameter = parameters[k].split(" ");
                                                                var incompatible = false;

                                                                if (currentParameter[0] == "ambiguous") {
                                                                    if (bufferParameterType != "ambiguous") {
                                                                        incompatible = true;
                                                                    }
                                                                }

                                                                if (incompatible) {

                                                                    generator.refactor.paramMDCount++;
                                                                    var initializeString = ["", "", ""];
                                                                    initializeString[0] = "ambiguous __param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    generator.includer.function.memory.gc();
                                                                    var tmpVar = new Variable("__param__init__" + currentParameter[1] + generator.refactor.paramMDCount, bufferParameterType, i);
                                                                    if (definitionStack.length > 0) {

                                                                        tmpVar.temporary = true;
                                                                        var exist = false;

                                                                        for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

                                                                            if (definitionStack[definitionStack.length - 1].variables[j] == tmpVar.name) {
                                                                                insideParameter = true;
                                                                                exist = true;
                                                                                break;
                                                                            }
                                                                        }

                                                                        if (!exist) {
                                                                            definitionStack[definitionStack.length - 1].variables.push(tmpVar.name);
                                                                        }
                                                                    }

                                                                    generator.refactor.insertVariable(tmpVar);

                                                                    if (bufferParameterType == generator.enums.c.data.type.string) {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue = ";
                                                                        initializeString[1]+= "( char * ) calloc(2048, sizeof( char ) )";
                                                                        initializeString[2]+= "sprintf(__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue, " + currentContentBuffer.data[k] + ")";
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    }
                                                                    else {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType + "Value = ";
                                                                        initializeString[1]+= "( " + bufferParameterType + " * ) calloc(1, sizeof( " + bufferParameterType + " ) )";
                                                                        initializeString[2]+= "(*__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType  + "Value"+ ") = ";
                                                                        initializeString[2]+= currentContentBuffer.data[k];
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount
                                                                    }

                                                                    for (var l = 0; l < 3; l++) {
                                                                        if (stack.content.length == 0) {
                                                                            line.contentStack.push(initializeString[l]);
                                                                        }
                                                                        else {
                                                                            stack.content[stack.content.length - 1].data.push(initializeString[l]);
                                                                        }
                                                                    }
                                                                }
                                                            }

                                                            result = candidate.function(currentContentBuffer.data);
														}
														catch (innerException) {

															throw innerException;
														}
													}
												}
											}
										}
										else if (operationType == generator.enums.c.data.type.float) {

											var list;
											var candidate;
											var result = "";
											if (currentFunction == generator.enums.c.data.type.integer) {
												result = "((" + generator.enums.c.data.type.integer + ")(" + currentContentBuffer.data.join(" ") + "))";
											}
											else if (currentFunction == generator.enums.symbol.float) {
												result = currentContentBuffer.data.join(" ");
											}
											else if (currentFunction == generator.enums.python.symbol.string) {

												list = dictionary.pages.findWordsByKeywords(["float-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data.join(" "));
											}
											else {
												// Function Analyser here
												try {

													var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
													result = candidate.function(currentContentBuffer.data);

												}
												catch (exception) {

													if (exception === dictionary.search.exception.NoEquivalent) {

														try {

                                                            var func = generator.refactor.getFunction(currentFunction);
                                                            var candidate = generator.c.to.python.processUserDefinedFunction(buffer, func, currentContentBuffer.data);


                                                            var parameters = generator.functions.search(candidate.name).param;
                                                            parameters = parameters.split(", ");

                                                            for (var k = 0; k < parameters.length; k++) {

                                                                var bufferParameterType = isEquation(currentContentBuffer.data[k]);
                                                                var currentParameter = parameters[k].split(" ");
                                                                var incompatible = false;

                                                                if (currentParameter[0] == "ambiguous") {
                                                                    if (bufferParameterType != "ambiguous") {
                                                                        incompatible = true;
                                                                    }
                                                                }

                                                                if (incompatible) {

                                                                    generator.refactor.paramMDCount++;
                                                                    var initializeString = ["", "", ""];
                                                                    initializeString[0] = "ambiguous __param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    generator.includer.function.memory.gc();
                                                                    var tmpVar = new Variable("__param__init__" + currentParameter[1] + generator.refactor.paramMDCount, bufferParameterType, i);
                                                                    if (definitionStack.length > 0) {

                                                                        tmpVar.temporary = true;
                                                                        var exist = false;

                                                                        for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

                                                                            if (definitionStack[definitionStack.length - 1].variables[j] == tmpVar.name) {
                                                                                insideParameter = true;
                                                                                exist = true;
                                                                                break;
                                                                            }
                                                                        }

                                                                        if (!exist) {
                                                                            definitionStack[definitionStack.length - 1].variables.push(tmpVar.name);
                                                                        }
                                                                    }

                                                                    generator.refactor.insertVariable(tmpVar);

                                                                    if (bufferParameterType == generator.enums.c.data.type.string) {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue = ";
                                                                        initializeString[1]+= "( char * ) calloc(2048, sizeof( char ) )";
                                                                        initializeString[2]+= "sprintf(__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue, " + currentContentBuffer.data[k] + ")";
                                                                        //currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    }
                                                                    else {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType + "Value = ";
                                                                        initializeString[1]+= "( " + bufferParameterType + " * ) calloc(1, sizeof( " + bufferParameterType + " ) )";
                                                                        initializeString[2]+= "(*__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType  + "Value"+ ") = ";
                                                                        initializeString[2]+= currentContentBuffer.data[k];
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    }


                                                                    for (var l = 0; l < 3; l++) {
                                                                        if (stack.content.length == 0) {
                                                                            line.contentStack.push(initializeString[l]);
                                                                        }
                                                                        else {
                                                                            stack.content[stack.content.length - 1].data.push(initializeString[l]);
                                                                        }
                                                                    }
                                                                }
                                                            }

                                                            result = candidate.function(currentContentBuffer.data);
                                                        }
                                                        catch (innerException) {

                                                            throw innerException;
                                                        }
													}
												}
											}
										}
										else {

											try {

													var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
													result = candidate.function(currentContentBuffer.data);

												}
												catch (exception) {

													if (exception === dictionary.search.exception.NoEquivalent) {

														try {

                                                            var func = generator.refactor.getFunction(currentFunction);
                                                            var candidate = generator.c.to.python.processUserDefinedFunction(buffer, func, currentContentBuffer.data);


                                                            var parameters = generator.functions.search(candidate.name).param;
                                                            parameters = parameters.split(", ");

                                                            for (var k = 0; k < parameters.length; k++) {

                                                                var bufferParameterType = isEquation(currentContentBuffer.data[k]);
                                                                var currentParameter = parameters[k].split(" ");
                                                                var incompatible = false;

                                                                if (currentParameter[0] == "ambiguous") {
                                                                    if (bufferParameterType != "ambiguous") {
                                                                        incompatible = true;
                                                                    }
                                                                }

                                                                if (incompatible) {

                                                                    generator.refactor.paramMDCount++;
                                                                    var initializeString = ["", "", ""];
                                                                    initializeString[0] = "ambiguous __param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    generator.includer.function.memory.gc();
                                                                    var tmpVar = new Variable("__param__init__" + currentParameter[1] + generator.refactor.paramMDCount, bufferParameterType, i);
                                                                    if (definitionStack.length > 0) {

                                                                        tmpVar.temporary = true;
                                                                        var exist = false;

                                                                        for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

                                                                            if (definitionStack[definitionStack.length - 1].variables[j] == tmpVar.name) {
                                                                                insideParameter = true;
                                                                                exist = true;
                                                                                break;
                                                                            }
                                                                        }

                                                                        if (!exist) {
                                                                            definitionStack[definitionStack.length - 1].variables.push(tmpVar.name);
                                                                        }
                                                                    }

                                                                    generator.refactor.insertVariable(tmpVar);

                                                                    if (bufferParameterType == generator.enums.c.data.type.string) {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue = ";
                                                                        initializeString[1]+= "( char * ) calloc(2048, sizeof( char ) )";
                                                                        initializeString[2]+= "sprintf(__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue, " + currentContentBuffer.data[k] + ")";
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    }
                                                                    else {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType + "Value = ";
                                                                        initializeString[1]+= "( " + bufferParameterType + " * ) calloc(1, sizeof( " + bufferParameterType + " ) )";
                                                                        initializeString[2]+= "(*__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType  + "Value"+ ") = ";
                                                                        initializeString[2]+= currentContentBuffer.data[k];
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount
                                                                    }

                                                                    for (var l = 0; l < 3; l++) {
                                                                        if (stack.content.length == 0) {
                                                                            line.contentStack.push(initializeString[l]);
                                                                        }
                                                                        else {
                                                                            stack.content[stack.content.length - 1].data.push(initializeString[l]);
                                                                        }
                                                                    }
                                                                }
                                                            }

                                                            result = candidate.function(currentContentBuffer.data);
                                                        }
                                                        catch (innerException) {

                                                            throw innerException;
                                                        }
													}
												}
										}

										if (stack.content.length == 0) {
											currentContentBuffer.result += result;
											contentBuffer.push(currentContentBuffer.result);
										}
										else {

											stack.content[stack.content.length - 1].data.push(result);
										}
									}

								}
								else if (line.values[j] == generator.enums.python.symbol.exponent) {
									exponent = true;
								}
								else if (line.values[j] == generator.enums.python.symbol.floorDivision) {
									floor = true;
								}
								else {
									pushToBuffer = true;
								}

								if (pushToBuffer) {
									contentBuffer.push(line.values[j]);
								}
							}
							else if (line.tokens[j] == generator.enums.token.keyword) {
								if (j + 1 != line.tokens.length) {
									if (line.values[j + 1] == generator.enums.symbol.leftParenthesis) {
										stack.count += 1;
										stack.functionName.push(line.values[j]);
										stack.content.push(new StackContent());
									}
								}
							}
							else if (line.tokens[j] == generator.enums.token.comment) {

                                var currentIndex 	= line.values[j].replace(/[^0-9.]/g, '');
                                contentBuffer.push("/*" + tokenizer.token.comment[currentIndex - 1].value + "*/");
							}

							if (stack.count > 0) {

								for (var k = lastContent.length; k < contentBuffer.length; k++) {

									stack.pushData(contentBuffer[k]);
								}

								contentBuffer = lastContent;
							}
						}
						//

						var content = "";
						for (var j = 0; j < contentBuffer.length; j++) {
							content += trimString(contentBuffer[j]);
							if (j + 1 < contentBuffer.length) {
								content += " ";
							}
						}

						line.contentStack.push(content);

					}

					if (isStr && legal) {

						var exponent = false;
						var floor = false;
						var stack = new ParenthesisStack();
						line.actionStack.push(action);
						var lastContent = "";
						contentBuffer = [];

						for (var j = 0; j < line.tokens.length; j++) {

							lastContent = contentBuffer.slice();

							if (line.tokens[j] == generator.enums.token.constant) {
								try {

									var constantValue = "";
									if (!isInteger(line.values[j])) {
										if (generator.options.useDoubleInsteadOfFloat) {
											constantValue += line.values[j];
										}
										else {
											constantValue += line.values[j] + "f";
										}
									}
									else {
										constantValue += line.values[j];
									}

									if (exponent) {
										exponent = false;
										var prevValue = "";
										if (stack.count > 0) {
											prevValue = stack.content[stack.content.length - 1].data.pop();
										}
										else {
											prevValue = contentBuffer.pop();
										}
										var parameter = [prevValue, ",", constantValue];
										var list = dictionary.pages.findWordsByKeywords(["math-operation", "exponent", "C-language"]);
										var candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
										contentBuffer.push(candidate.function(parameter));
									}
									else if (floor) {
										floor = false;
									}
									else {
										contentBuffer.push(constantValue);
									}
								}
								catch (exception) {

									legal = false;
								}
							}
							else if (line.tokens[j] == generator.enums.token.identifier) {

								var identifier = null;
								for (var k = 0; k < line.actionStack.length; k++) {

									for (var l = 0; l < line.actionStack[k].state.length; l++) {

										if (line.values[j] == line.actionStack[k].state[l].name) {

											identifier = line.actionStack[k].state[l];
											break;
										}
									}
								}

								if (identifier != null) {

									if (identifier.ambiguous) {
										if (identifier.type == generator.enums.c.data.type.string) {
											contentBuffer.push(identifier.name + ".charValue");
										}
										else {
											contentBuffer.push("(*" + identifier.name+ "." + identifier.type + "Value)");
										}
									}
									else {
										contentBuffer.push(identifier.name);
									}
								}

							}
							else if (line.tokens[j] == generator.enums.token.reserveWord) {

								if (line.values[j] == generator.enums.c.data.type.integer ||
									line.values[j] == generator.enums.python.data.type.float ||
									line.values[j] == generator.enums.python.symbol.string) {
									if (j + 1 != line.tokens.length) {
										if (line.values[j + 1] == generator.enums.symbol.leftParenthesis) {
											stack.count += 1;
											stack.functionName.push(line.values[j]);
											stack.content.push(new StackContent());
										}
									}
								}
								else if (line.values[j] == generator.enums.python.symbol.true) {
                                    contentBuffer.push(generator.enums.c.symbol.true);
								}
								else if (line.values[j] == generator.enums.python.symbol.false) {
                                    contentBuffer.push(generator.enums.c.symbol.false);
								}
								else if (line.values[j] == generator.enums.python.symbol.not) {
                                    contentBuffer.push(generator.enums.c.symbol.not);
								}
								else if (line.values[j] == generator.enums.python.symbol.and) {
                                    contentBuffer.push(generator.enums.c.symbol.and);
								}
								else if (line.values[j] == generator.enums.python.symbol.or) {
                                    contentBuffer.push(generator.enums.c.symbol.or);
								}
							}
							else if (line.tokens[j] == generator.enums.token.stringConstant) {

								contentBuffer.push(line.values[j]);
							}
							else if (line.tokens[j] == generator.enums.token.symbol) {

								var pushToBuffer = false;

								if (line.values[j] == generator.enums.symbol.leftParenthesis) {

									if (stack.count > 0) {
										if (!((line.values[j - 1] == generator.enums.c.data.type.integer ||
											line.values[j - 1] == generator.enums.python.data.type.float ||
											line.values[j - 1] == generator.enums.python.symbol.string) ||
											line.tokens[j - 1] == generator.enums.token.keyword)) {
											pushToBuffer = true;
											stack.set++;
										}
									}
									else {
										pushToBuffer = true;
									}
								}
								else if (line.values[j] == generator.enums.symbol.rightParenthesis) {

									if (stack.set > 0) {
										stack.set--;
									}

									if (stack.count == 0) {
										pushToBuffer = true;
									}

									if (stack.set == 0 && stack.count > 0) {

										stack.count--;
										var currentFunction = stack.functionName.pop();
										var currentContentBuffer = stack.content.pop();

										var tmpEquation = currentContentBuffer.data.slice();

										for (var k = 0; k < tmpEquation.length; k++) {

											if (tmpEquation[k].search("intValue") != -1) {

												tmpEquation[k] = tmpEquation[k].substring(1).replace(RegExp('\\b' + ".intValue" + '\\b','g'), "");
											}
											else if (tmpEquation[k].search("intValue") != -1) {
												tmpEquation[k] = tmpEquation[k].substring(1).replace(RegExp('\\b' + ".floatValue" + '\\b','g'), "");
											}
											else if (tmpEquation[k].search("charValue") != -1) {
												tmpEquation[k] = tmpEquation[k].replace(RegExp('\\b' + ".charValue" + '\\b','g'), "");
											}
										}

										var operationType = isEquation(tmpEquation.join(" "));
										//alert(operationType + "-" + currentFunction + " = " + currentContentBuffer.data.join(" "));
										if (operationType == generator.enums.c.data.type.string) {

											var list;
											var candidate;
											var result = "";

											if (currentFunction == generator.enums.c.data.type.integer) {

												if (currentContentBuffer.data.length > 1) {
													//alert(currentContentBuffer.data.join(","));
													for (var k = 0; k < currentContentBuffer.data.length; k++) {
														if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
															currentContentBuffer.data.splice(k, 1);
															k--;
														}
													}

													list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
													result = candidate.function(currentContentBuffer.data);

													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.integer, 3);
													result = candidate.function(result);
												}
												else {
													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.integer, 3);
													result = candidate.function(currentContentBuffer.data);
												}
											}
											else if (currentFunction == generator.enums.python.data.type.float) {

												if (currentContentBuffer.data.length > 1) {

													for (var k = 0; k < currentContentBuffer.data.length; k++) {
														if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
															currentContentBuffer.data.splice(k, 1);
															k--;
														}
													}

													list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
													result = candidate.function(currentContentBuffer.data);

													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
													result = candidate.function(result);
												}
												else {
													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
													result = candidate.function(currentContentBuffer.data);
												}

											}
											else if (currentFunction == generator.enums.python.symbol.string) {

												for (var k = 0; k < currentContentBuffer.data.length; k++) {
													if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
														currentContentBuffer.data.splice(k, 1);
														k--;
													}
												}

												list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data);
											}
											else {

												try {

													var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
													result = candidate.function(currentContentBuffer.data);

												}
												catch (exception) {

													if (exception === dictionary.search.exception.NoEquivalent) {

														try {

                                                            var func = generator.refactor.getFunction(currentFunction);
                                                            var candidate = generator.c.to.python.processUserDefinedFunction(buffer, func, currentContentBuffer.data);


                                                            var parameters = generator.functions.search(candidate.name).param;
                                                            parameters = parameters.split(", ");

                                                            for (var k = 0; k < parameters.length; k++) {

                                                                var bufferParameterType = isEquation(currentContentBuffer.data[k]);
                                                                var currentParameter = parameters[k].split(" ");
                                                                var incompatible = false;

                                                                if (currentParameter[0] == "ambiguous") {
                                                                    if (bufferParameterType != "ambiguous") {
                                                                        incompatible = true;
                                                                    }
                                                                }

                                                                if (incompatible) {

                                                                    generator.refactor.paramMDCount++;
                                                                    var initializeString = ["", "", ""];
                                                                    initializeString[0] = "ambiguous __param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    generator.includer.function.memory.gc();
                                                                    var tmpVar = new Variable("__param__init__" + currentParameter[1] + generator.refactor.paramMDCount, bufferParameterType, i);
                                                                    if (definitionStack.length > 0) {

                                                                        tmpVar.temporary = true;
                                                                        var exist = false;

                                                                        for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

                                                                            if (definitionStack[definitionStack.length - 1].variables[j] == tmpVar.name) {
                                                                                insideParameter = true;
                                                                                exist = true;
                                                                                break;
                                                                            }
                                                                        }

                                                                        if (!exist) {
                                                                            definitionStack[definitionStack.length - 1].variables.push(tmpVar.name);
                                                                        }
                                                                    }

                                                                    generator.refactor.insertVariable(tmpVar);

                                                                    if (bufferParameterType == generator.enums.c.data.type.string) {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue = ";
                                                                        initializeString[1]+= "( char * ) calloc(2048, sizeof( char ) )";
                                                                        initializeString[2]+= "sprintf(__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue, " + currentContentBuffer.data[k] + ")";
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    }
                                                                    else {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType + "Value = ";
                                                                        initializeString[1]+= "( " + bufferParameterType + " * ) calloc(1, sizeof( " + bufferParameterType + " ) )";
                                                                        initializeString[2]+= "(*__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType  + "Value"+ ") = ";
                                                                        initializeString[2]+= currentContentBuffer.data[k];
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount
                                                                    }

                                                                    for (var l = 0; l < 3; l++) {
                                                                        if (stack.content.length == 0) {
                                                                            line.contentStack.push(initializeString[l]);
                                                                        }
                                                                        else {
                                                                            stack.content[stack.content.length - 1].data.push(initializeString[l]);
                                                                        }
                                                                    }
                                                                }
                                                            }

                                                            result = candidate.function(currentContentBuffer.data);
                                                        }
                                                        catch (innerException) {

                                                            throw innerException;
                                                        }
													}
												}
											}
										}
										else if (operationType == generator.enums.c.data.type.integer) {

											var list;
											var candidate;
											var result = "";

											if (currentFunction == generator.enums.c.data.type.integer) {
												result = currentContentBuffer.data.join(" ");
											}
											else if (currentFunction == generator.enums.python.data.type.float) {
												result = "((" + generator.enums.c.data.type.float + ")(" + currentContentBuffer.data.join(" ") + "))";
											}
											else if (currentFunction == generator.enums.python.symbol.string) {
												list = dictionary.pages.findWordsByKeywords(["integer-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data.join(" "));
											}
											else {
												//alert(currentContentBuffer.data.join("-"));
												try {

													var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
													result = candidate.function(currentContentBuffer.data);

												}
												catch (exception) {

													if (exception === dictionary.search.exception.NoEquivalent) {

														try {

                                                            var func = generator.refactor.getFunction(currentFunction);
                                                            var candidate = generator.c.to.python.processUserDefinedFunction(buffer, func, currentContentBuffer.data);


                                                            var parameters = generator.functions.search(candidate.name).param;
                                                            parameters = parameters.split(", ");

                                                            for (var k = 0; k < parameters.length; k++) {

                                                                var bufferParameterType = isEquation(currentContentBuffer.data[k]);
                                                                var currentParameter = parameters[k].split(" ");
                                                                var incompatible = false;

                                                                if (currentParameter[0] == "ambiguous") {
                                                                    if (bufferParameterType != "ambiguous") {
                                                                        incompatible = true;
                                                                    }
                                                                }

                                                                if (incompatible) {

                                                                    generator.refactor.paramMDCount++;
                                                                    var initializeString = ["", "", ""];
                                                                    initializeString[0] = "ambiguous __param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    generator.includer.function.memory.gc();
                                                                    var tmpVar = new Variable("__param__init__" + currentParameter[1] + generator.refactor.paramMDCount, bufferParameterType, i);
                                                                    if (definitionStack.length > 0) {

                                                                        tmpVar.temporary = true;
                                                                        var exist = false;

                                                                        for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

                                                                            if (definitionStack[definitionStack.length - 1].variables[j] == tmpVar.name) {
                                                                                insideParameter = true;
                                                                                exist = true;
                                                                                break;
                                                                            }
                                                                        }

                                                                        if (!exist) {
                                                                            definitionStack[definitionStack.length - 1].variables.push(tmpVar.name);
                                                                        }
                                                                    }

                                                                    generator.refactor.insertVariable(tmpVar);

                                                                    if (bufferParameterType == generator.enums.c.data.type.string) {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue = ";
                                                                        initializeString[1]+= "( char * ) calloc(2048, sizeof( char ) )";
                                                                        initializeString[2]+= "sprintf(__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue, " + currentContentBuffer.data[k] + ")";
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    }
                                                                    else {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType + "Value = ";
                                                                        initializeString[1]+= "( " + bufferParameterType + " * ) calloc(1, sizeof( " + bufferParameterType + " ) )";
                                                                        initializeString[2]+= "(*__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType  + "Value"+ ") = ";
                                                                        initializeString[2]+= currentContentBuffer.data[k];
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount
                                                                    }

                                                                    for (var l = 0; l < 3; l++) {
                                                                        if (stack.content.length == 0) {
                                                                            line.contentStack.push(initializeString[l]);
                                                                        }
                                                                        else {
                                                                            stack.content[stack.content.length - 1].data.push(initializeString[l]);
                                                                        }
                                                                    }
                                                                }
                                                            }

                                                            result = candidate.function(currentContentBuffer.data);
                                                        }
                                                        catch (innerException) {

                                                            throw innerException;
                                                        }
													}
												}
											}
										}
										else if (operationType == generator.enums.c.data.type.float) {

											var list;
											var candidate;
											var result = "";
											if (currentFunction == generator.enums.c.data.type.integer) {
												result = "((" + generator.enums.c.data.type.integer + ")(" + currentContentBuffer.data.join(" ") + "))";
											}
											else if (currentFunction == generator.enums.symbol.float) {
												result = currentContentBuffer.data.join(" ");
											}
											else if (currentFunction == generator.enums.python.symbol.string) {

												list = dictionary.pages.findWordsByKeywords(["float-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data.join(" "));
											}
											else {
												// Function Analyser here
												try {

													var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
													result = candidate.function(currentContentBuffer.data);

												}
												catch (exception) {

													if (exception === dictionary.search.exception.NoEquivalent) {

														try {

                                                            var func = generator.refactor.getFunction(currentFunction);
                                                            var candidate = generator.c.to.python.processUserDefinedFunction(buffer, func, currentContentBuffer.data);


                                                            var parameters = generator.functions.search(candidate.name).param;
                                                            parameters = parameters.split(", ");

                                                            for (var k = 0; k < parameters.length; k++) {

                                                                var bufferParameterType = isEquation(currentContentBuffer.data[k]);
                                                                var currentParameter = parameters[k].split(" ");
                                                                var incompatible = false;

                                                                if (currentParameter[0] == "ambiguous") {
                                                                    if (bufferParameterType != "ambiguous") {
                                                                        incompatible = true;
                                                                    }
                                                                }

                                                                if (incompatible) {

                                                                    generator.refactor.paramMDCount++;
                                                                    var initializeString = ["", "", ""];
                                                                    initializeString[0] = "ambiguous __param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    generator.includer.function.memory.gc();
                                                                    var tmpVar = new Variable("__param__init__" + currentParameter[1] + generator.refactor.paramMDCount, bufferParameterType, i);
                                                                    if (definitionStack.length > 0) {

                                                                        tmpVar.temporary = true;
                                                                        var exist = false;

                                                                        for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

                                                                            if (definitionStack[definitionStack.length - 1].variables[j] == tmpVar.name) {
                                                                                insideParameter = true;
                                                                                exist = true;
                                                                                break;
                                                                            }
                                                                        }

                                                                        if (!exist) {
                                                                            definitionStack[definitionStack.length - 1].variables.push(tmpVar.name);
                                                                        }
                                                                    }

                                                                    generator.refactor.insertVariable(tmpVar);

                                                                    if (bufferParameterType == generator.enums.c.data.type.string) {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue = ";
                                                                        initializeString[1]+= "( char * ) calloc(2048, sizeof( char ) )";
                                                                        initializeString[2]+= "sprintf(__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue, " + currentContentBuffer.data[k] + ")";
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    }
                                                                    else {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType + "Value = ";
                                                                        initializeString[1]+= "( " + bufferParameterType + " * ) calloc(1, sizeof( " + bufferParameterType + " ) )";
                                                                        initializeString[2]+= "(*__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType  + "Value"+ ") = ";
                                                                        initializeString[2]+= currentContentBuffer.data[k];
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount
                                                                    }

                                                                    for (var l = 0; l < 3; l++) {
                                                                        if (stack.content.length == 0) {
                                                                            line.contentStack.push(initializeString[l]);
                                                                        }
                                                                        else {
                                                                            stack.content[stack.content.length - 1].data.push(initializeString[l]);
                                                                        }
                                                                    }
                                                                }
                                                            }

                                                            result = candidate.function(currentContentBuffer.data);
                                                        }
                                                        catch (innerException) {

                                                            throw innerException;
                                                        }
													}
												}
											}
										}
										else {
											try {

												var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
												result = candidate.function(currentContentBuffer.data);

											}
											catch (exception) {

												if (exception === dictionary.search.exception.NoEquivalent) {

													try {

                                                        var func = generator.refactor.getFunction(currentFunction);
                                                        var candidate = generator.c.to.python.processUserDefinedFunction(buffer, func, currentContentBuffer.data);


                                                        var parameters = generator.functions.search(candidate.name).param;
                                                        parameters = parameters.split(", ");

                                                        for (var k = 0; k < parameters.length; k++) {

                                                            var bufferParameterType = isEquation(currentContentBuffer.data[k]);
                                                            var currentParameter = parameters[k].split(" ");
                                                            var incompatible = false;

                                                            if (currentParameter[0] == "ambiguous") {
                                                                if (bufferParameterType != "ambiguous") {
                                                                    incompatible = true;
                                                                }
                                                            }

                                                            if (incompatible) {

                                                                generator.refactor.paramMDCount++;
                                                                var initializeString = ["", "", ""];
                                                                initializeString[0] = "ambiguous __param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                generator.includer.function.memory.gc();
                                                                var tmpVar = new Variable("__param__init__" + currentParameter[1] + generator.refactor.paramMDCount, bufferParameterType, i);
                                                                if (definitionStack.length > 0) {

                                                                    tmpVar.temporary = true;
                                                                       var exist = false;

                                                                    for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

                                                                        if (definitionStack[definitionStack.length - 1].variables[j] == tmpVar.name) {
                                                                            insideParameter = true;
                                                                            exist = true;
                                                                            break;
                                                                        }
                                                                    }

                                                                    if (!exist) {
                                                                        definitionStack[definitionStack.length - 1].variables.push(tmpVar.name);
                                                                    }
                                                                }

                                                                generator.refactor.insertVariable(tmpVar);

                                                                if (bufferParameterType == generator.enums.c.data.type.string) {
                                                                    initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue = ";
                                                                    initializeString[1]+= "( char * ) calloc(2048, sizeof( char ) )";
                                                                    initializeString[2]+= "sprintf(__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue, " + currentContentBuffer.data[k] + ")";
                                                                    currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                }
                                                                else {
                                                                    initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType + "Value = ";
                                                                    initializeString[1]+= "( " + bufferParameterType + " * ) calloc(1, sizeof( " + bufferParameterType + " ) )";
                                                                    initializeString[2]+= "(*__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType  + "Value"+ ") = ";
                                                                    initializeString[2]+= currentContentBuffer.data[k];
                                                                    currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount
                                                                }

                                                                for (var l = 0; l < 3; l++) {
                                                                    if (stack.content.length == 0) {
                                                                        line.contentStack.push(initializeString[l]);
                                                                    }
                                                                    else {
                                                                        stack.content[stack.content.length - 1].data.push(initializeString[l]);
                                                                    }
                                                                }
                                                            }
                                                        }

                                                        result = candidate.function(currentContentBuffer.data);
                                                    }
                                                    catch (innerException) {

                                                        throw innerException;
                                                    }
												}
											}
										}


										if (stack.content.length == 0) {
											currentContentBuffer.result += result;
											contentBuffer.push(currentContentBuffer.result);;
										}
										else {

											stack.content[stack.content.length - 1].data.push(result);
										}
									}
								}
								else if (line.values[j] == generator.enums.python.symbol.exponent) {
									exponent = true;
								}
								else if (line.values[j] == generator.enums.python.symbol.floorDivision) {
									floor = true;
								}
								else {
									pushToBuffer = true;
								}

								if (pushToBuffer) {
									contentBuffer.push(line.values[j]);
								}
							}
							else if (line.tokens[j] == generator.enums.token.keyword) {

								if (j + 1 != line.tokens.length) {
									if (line.values[j + 1] == generator.enums.symbol.leftParenthesis) {
										stack.count += 1;
										stack.functionName.push(line.values[j]);
										stack.content.push(new StackContent());
									}
								}
							}

							if (stack.count > 0) {

								for (var k = lastContent.length; k < contentBuffer.length; k++) {

									stack.pushData(contentBuffer[k]);
								}

								contentBuffer = lastContent;
							}
						}

						var paramList = [];
						var strBuffer = "";
						var content = "";

						for (var j = 0; j < contentBuffer.length; j++) {


							if (!(contentBuffer[j] == generator.enums.symbol.add || contentBuffer[j] == generator.enums.symbol.equal)) {
								try {

									var arrayList = JSON.parse(contentBuffer[j]);
									if (typeof(arrayList) === generator.enums.c.data.type.object) {

										for (var k = 0; k < arrayList.length; k++) {
											paramList.push(arrayList[k]);
										}
									}
									else {
										paramList.push(contentBuffer[j]);
									}

								}
								catch (exception) {

									paramList.push(contentBuffer[j]);
								}
							}
						}


						//////////////////////////////////////////////////////////////
						//To do: Make the parameters convert data-types when needed.//
						//////////////////////////////////////////////////////////////

						for (var j = 0; j < paramList.length; j++) {

							if (paramList[j].search("intValue") != -1) {
								paramList[j] = paramList[j].substring(1).replace(RegExp('\\b' + ".intValue" + '\\b','g'), "");
							}
							else if (paramList[j].search("intValue") != -1) {
								paramList[j] = paramList[j].substring(1).replace(RegExp('\\b' + ".floatValue" + '\\b','g'), "");
							}
							else if (paramList[j].search("charValue") != -1) {
								paramList[j] = paramList[j].replace(RegExp('\\b' + ".charValue" + '\\b','g'), "");
							}

							try {

								var link = generator.refactor.getVariable(paramList[j]);
								if (link.ambiguous) {

									if (link.type == "int") {

										var list = dictionary.pages.findWordsByKeywords(["integer-only", "data-type-conversion", "C-language"]);
										var candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
										paramList[j] = candidate.function("*" + paramList[j] + ".intValue");
									}
									else if (link.type == "float") {

										var list = dictionary.pages.findWordsByKeywords(["float-only", "data-type-conversion", "C-language"]);
										var candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
										paramList[j] = candidate.function("*" + paramList[j] + ".floatValue");
									}
									else if (link.type == "string") {

										paramList[j] = paramList[j] + ".charValue";
									}
								}
								else {

									if (link.type == "int") {

										var list = dictionary.pages.findWordsByKeywords(["integer-only", "data-type-conversion", "C-language"]);
										var candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
										paramList[j] = candidate.function(paramList[j]);
									}
									else if (link.type == "float") {

										var list = dictionary.pages.findWordsByKeywords(["float-only", "data-type-conversion", "C-language"]);
										var candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
										paramList[j] = candidate.function(paramList[j]);
									}
									else if (link.type == "string") {

										//alert("@@@@");
									}
								}
							}
							catch (exception2) {

							}
						}

						var list;
						var candidate;
						var result;

						if (action.type == generator.enums.action.compoundAssignment) {

							result = dictionary.pages.findWord("sprintf", "C-language").function(paramList[0], paramList.slice(0, 1).concat(paramList.slice(2)));
						}
						else {

							if (action.type == generator.enums.action.basic.id || action.type == generator.enums.c.action.return.undefined || action.type == generator.enums.c.action.return.string || action.type == generator.enums.c.action.return.const || paramList.length <= 1) {

								result = contentBuffer;
							}
							else {

								list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
								candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
								result = candidate.function(paramList);
							}
						}

						if (action.type == generator.enums.action.return.void ||
							action.type == generator.enums.action.return.constant ||
							action.type == generator.enums.action.return.string) {

							hasReturnType = true;
							result = "return " + result;
						}
						line.contentStack.push(result);
					}


					if (!legal) {

						if (generator.options.detailedErrors) {
							line.contentStack = [];
							errorHandler.raiseError(new Error(line.lineNumber + 1, line.values.slice(), errorDescription));
						}
					}

					return line;
				},

				processDeclarativeStatement: function (buffer, line, action, legal, definitionStack, currentLanguage, targetLanguage) {

					line = clone.line(line);

					var isStr =
					action.type == generator.enums.action.stringDeclaration ? true : false;
					var contentBuffer = [];
					var newDeclaration = false;
					var variable = null;
					var initialize = false;
					var typeCasted = false;
					var numericVariables = 0;
					var checkStack = new ParenthesisStack();
					var errorDescription = "";

					for (var j = 0; j < line.tokens.length; j++) {

						if (line.tokens[j] == generator.enums.token.identifier) {

							try {

								if (!initialize) {

									variable = generator.refactor.findVariable(line.values[j]);
									if (variable == -1) {

										variable = new Variable(line.values[j], 0, i);
										newDeclaration = true;
									}
									else {

										variable = clone.variable(generator.refactor.variableList[variable]);
										if (variable.type == 0 && variable.temporary) {

											generator.refactor.variableList.splice(generator.refactor.findVariable(line.values[j]), 1);
											variable = new Variable(line.values[j], 0, i);
											newDeclaration = true;
										}
									}

									initialize = true;
								}
								else {

									var tmpVariable =
										generator.refactor.getVariable(line.values[j]);

									action.pushVariableState(tmpVariable);
									if (tmpVariable.type == generator.enums.c.data.type.integer ||
										tmpVariable.type == generator.enums.c.data.type.float ||
										tmpVariable.type == generator.enums.c.data.type.bool) {

										if (variable.type == 0 ||
											variable.type != generator.enums.c.data.type.float) {
											variable.type = tmpVariable.type;
										}

										if (!typeCasted && isStr) {
											numericVariables += 1;
										}

									}
									else {

										if (!typeCasted) {
											isStr = true;
											if (variable.type == generator.enums.c.data.type.integer ||
												variable.type == generator.enums.c.data.type.float ||
												variable.type == generator.enums.c.data.type.bool) {

												legal = false;
											}
											else {

												variable.type = generator.enums.c.data.type.string;
											}
										}
									}
								}

							}
							catch (exception) {

								errorDescription = exception;
								legal = false;
							}
						}
						else if (line.tokens[j] == generator.enums.token.constant) {

							if (variable.type == 0) {
								try {

									variable.type = isInteger(line.values[j]) ?
										generator.enums.c.data.type.integer :
										generator.enums.c.data.type.float;
								}
								catch (exception) {

									errorDescription = "Illegal usage of constant expression";
									legal = false;
								}
							}
							else if (variable.type == generator.enums.python.data.type.string) {

								variable.type = isInteger(line.values[j]) ?
									generator.enums.c.data.type.integer :
									generator.enums.c.data.type.float;
							}
							else {

								try {
									variable.type = isInteger(line.values[j]) ?
										generator.enums.c.data.type.integer :
										generator.enums.c.data.type.float;
								}
								catch (exception) {
									errorDescription = "Illegal usage of string literals";
									legal = false;
								}
							}

							if (!typeCasted && isStr) {
								numericVariables += 1;
							}
						}
						else if (line.tokens[j] == generator.enums.token.stringConstant) {

							if (variable.type == 0 && !typeCasted) {
								variable.type = generator.enums.c.data.type.string;
							}
						}
						else if (line.tokens[j] == generator.enums.token.reserveWord) {

							if (line.values[j] == generator.enums.c.data.type.integer ||
								line.values[j] == generator.enums.python.data.type.float) {

								if (variable.type == 0 ||
									variable.type != generator.enums.c.data.type.float) {

									variable.type = line.values[j]
										== generator.enums.c.data.type.integer ?
										generator.enums.c.data.type.integer :
										generator.enums.c.data.type.float;
								}

								typeCasted = true;
							}
							else if (line.values[j] == generator.enums.python.symbol.string) {

								typeCasted = true;
							}
							else if (line.values[j] == generator.enums.python.symbol.true ||
									 line.values[j] == generator.enums.python.symbol.false||
									 line.values[j] == generator.enums.python.symbol.not ||
									 line.values[j] == generator.enums.python.symbol.and ||
									 line.values[j] == generator.enums.python.symbol.or) {

								generator.headers.insert("stdbool.h");
								if (variable.type == 0) {

									variable.type = generator.enums.c.data.type.bool;
								}
							}
						}
						else if (line.tokens[j] == generator.enums.token.keyword) {

							var keyword = dictionary.pages.findWord(line.values[j], currentLanguage);
							var funcType = "";
							try {
                                var equivKeyword = dictionary.search.equivalentWord(targetLanguage, keyword);

                                if (keyword.returnType == generator.enums.python.data.structure.list) {

									funcType = equivKeyword.returnType + " *";
                                }
                                else {

									funcType = equivKeyword.returnType;
                                }
                                //Put data type comparison here :)
							}
							catch (exception) {

                                funcType = keyword.returnType;
							}


							if (variable.type == 0 ||
								variable.type != generator.enums.c.data.type.float &&
								variable.type != generator.enums.c.data.type.bool) {

								if (funcType == generator.enums.c.data.type.float ||
									funcType == generator.enums.c.data.type.integer) {

									variable.type = funcType;
									if (!typeCasted && isStr) {
										numericVariables++;
									}
								}
								else {

									if (funcType == generator.enums.c.data.type.void) {
										errorDescription = "function " + keyword.name + " does not define a data type.";
										legal = false;
									}
									else if (funcType == generator.enums.c.data.type.string && !typeCasted) {
										isStr = true;
										variable.type = generator.enums.c.data.type.string;
									}
									else if (funcType == generator.enums.c.data.type.integer ||
											 funcType == generator.enums.c.data.type.float) {

										variable.type = variable.type == generator.enums.c.data.type.float ? float : funcType;
										if (!typeCasted && isStr) {
											numericVariables++;
										}
									}
									else {

										variable.type = funcType;
									}
								}
							}
							else {

								if (funcType == generator.enums.c.data.type.void) {
									errorDescription = "function " + keyword.name + " does not define a data type.";
									legal = false;
								}
								else if (funcType == generator.enums.c.data.type.string && !typeCasted) {
									isStr = true;
								}
								else if (funcType == generator.enums.c.data.type.integer ||
										 funcType == generator.enums.c.data.type.float) {

									if (!typeCasted && isStr) {
										numericVariables++;
									}
								}
								else {

									variable.type = funcType;
								}
							}
						}
						else if (line.tokens[j] == generator.enums.token.symbol) {

							if (line.values[j] == generator.enums.symbol.leftParenthesis) {

								if (typeCasted) {
									checkStack.set++;
								}
							}
							else if (line.values[j] == generator.enums.symbol.rightParenthesis) {

								if (checkStack.set > 0) {
									checkStack.set--;
								}

								if (checkStack.count == 0) {
									typeCasted = false;
								}

								if (checkStack.set == 0 && checkStack.count > 0) {
									checkStack.count--;
								}
							}
							else if (line.values[j] == generator.enums.python.symbol.exponent) {

								if (variable.type == 0 ||
									variable.type != generator.enums.c.data.type.float) {

									variable.type = generator.enums.c.data.type.float;
								}
							}
							else if (line.values[j] == generator.enums.symbol.lessThan ||
									 line.values[j] == generator.enums.symbol.greaterThan) {

								variable.type = generator.enums.c.data.type.bool;
							}
						}
					}

					//alert(isStr + "  " + numericVariables + "  " + legal);
					if ((isStr && numericVariables > 0) || variable.type == 0) {
						errorDescription = "String and Numeric variables cannot be added directly";
						legal = false;
					}
					if (variable.type == generator.enums.c.data.type.bool) {

						generator.headers.insert("stdbool.h");
					}

					if (action.type == generator.enums.action.arrayAssignment) {

                        if (variable.type == generator.enums.c.data.type.integer) {

                            variable.type = generator.enums.c.data.type.array.integer;
                        }
                        else if (variable.type == generator.enums.c.data.type.float) {

                            variable.type = generator.enums.c.data.type.array.float;
                        }
                        else if (variable.type == generator.enums.c.data.type.bool) {

                            variable.type = generator.enums.c.data.type.array.bool;
                        }
                        else if (variable.type == generator.enums.c.data.type.string) {

                            variable.type = generator.enums.c.data.type.array.string;
                        }
                        else if (variable.type == generator.enums.c.data.type.object) {

                            variable.type = generator.enums.c.data.type.array.object;
                        }
					}

					if (!isStr && legal) {

						var previousVariable = "";

						if (!newDeclaration) {

							if (definitionStack.length > 0) {

								definitionStack[definitionStack.length - 1].original.push(variable);
								if (definitionStack[definitionStack.length - 1].definitionType == generator.enums.definition.function) {

									newDeclaration = true;
									generator.refactor.removeVariable(variable.name);
								}
							}
							else {

								generator.c.to.python.refactor(variable, buffer);
								if (variable.ambiguous) {

									if (generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type != variable.type) {

										var fcontent = "";
										var content = "";
										var allocContent = "";

										if (generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type == generator.enums.c.data.type.string) {

											fcontent += generator.refactor.variableList[generator.refactor.findVariable(variable.name)].name + ".charValue";
										}
										else {

											fcontent += generator.refactor.variableList[generator.refactor.findVariable(variable.name)].name + "." + generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type + "Value";
										}

										if (variable.type == generator.enums.c.data.type.string) {

											allocContent = "( char * ) calloc(2048, sizeof( char ) )";
											content += generator.refactor.variableList[generator.refactor.findVariable(variable.name)].name + ".charValue";
										}
										else {

											allocContent = "( " + variable.type + " * ) calloc(1, sizeof( " + variable.type + " ) )";
											content += variable.name + "." + variable.type + "Value";
										}

										line.contentStack.push("free(" + fcontent + ")");
										line.contentStack.push(content + " = " + allocContent);
									}
								}

								previousVariable = generator.refactor.variableList[generator.refactor.findVariable(variable.name)];
								generator.refactor.variableList[generator.refactor.findVariable(variable.name)] = variable;
							}
						}

						if (newDeclaration) {

							var insideParameter = false;
							//alert(variable.type);

							if (definitionStack.length > 0) {

								variable.temporary = true;
								var exist = false;

								for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

									if (definitionStack[definitionStack.length - 1].variables[j] == variable.name) {
										insideParameter = true;
										exist = true;
										break;
									}
								}

								if (!exist) {
									definitionStack[definitionStack.length - 1].variables.push(variable.name);
								}

							}

							generator.refactor.insertVariable(variable);

							if (!insideParameter)
								contentBuffer.push(variable.type);
						}


						action.pushVariableState(variable);
						line.actionStack.push(action);

						// Code Generation Phase

						var exponent = false;
						var floor = false;
						var stack = new ParenthesisStack();
						var lastContent = "";


						for (var j = 0; j < line.tokens.length; j++) {

							lastContent = contentBuffer.slice();

							if (line.tokens[j] == generator.enums.token.constant) {
								try {

									var constantValue = "";
									if (!isInteger(line.values[j])) {
										if (generator.options.useDoubleInsteadOfFloat) {
											constantValue += line.values[j];
										}
										else {
											constantValue += line.values[j] + "f";
										}
									}
									else {
										constantValue += line.values[j];
									}

									if (exponent) {

										exponent = false;
										var prevValue = "";
										if (stack.count > 0) {
											prevValue = stack.content[stack.content.length - 1].data.pop();
										}
										else {
											prevValue = contentBuffer.pop();
										}
										var parameter = [prevValue, ",", constantValue];
										var list = dictionary.pages.findWordsByKeywords(["math-operation", "exponent", "C-language"]);
										var candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
										contentBuffer.push(candidate.function(parameter));
									}
									else if (floor) {
										floor = false;
									}
									else {
										contentBuffer.push(constantValue);
									}

								}
								catch (exception) {

									legal = false;
								}
							}
							else if (line.tokens[j] == generator.enums.token.identifier) {

								var identifier = null;
								for (var k = 0; k < line.actionStack.length; k++) {

									for (var l = 0; l < line.actionStack[k].state.length; l++) {

										if (line.values[j] == line.actionStack[k].state[l].name) {

											identifier = line.actionStack[k].state[l];
											break;
										}
									}
								}

								if (identifier != null) {
									if (identifier.lineDeclared != i && j != 0) {


										if (identifier.type != variable.type && stack.count == 0) {

											if (variable.type == generator.enums.c.data.type.integer ||
												variable.type == generator.enums.c.data.type.float) {
												contentBuffer.push("(" + variable.type + ")");
											}
											else if (identifier.type == generator.enums.c.data.type.string) {

												if (variable.type == generator.enums.c.data.type.integer) {
													generator.includer.function.parser.integer.string();
												}
												else if (variable.type == generator.enums.c.data.type.float) {
													generator.includer.function.parser.float.string();
												}
											}
										}
									}
                                    //alert(identifier.name + " " + identifier.ambiguous);
									if (identifier.ambiguous) {
										if (identifier.type == generator.enums.c.data.type.string) {
											contentBuffer.push(identifier.name + ".charValue");
										}
										else {
											contentBuffer.push("(*" + identifier.name+ "." + identifier.type + "Value)");
										}

									}
									else {
										contentBuffer.push(identifier.name);
									}
								}
							}
							else if (line.tokens[j] == generator.enums.token.reserveWord) {

								if (line.values[j] == generator.enums.c.data.type.integer ||
									line.values[j] == generator.enums.python.data.type.float ||
									line.values[j] == generator.enums.python.symbol.string) {

									if (j + 1 != line.tokens.length) {
										if (line.values[j + 1] == generator.enums.symbol.leftParenthesis) {
											stack.count += 1;
											stack.functionName.push(line.values[j]);
											stack.content.push(new StackContent());
										}
									}
								}
								else if (line.values[j] == generator.enums.python.symbol.true) {
                                    contentBuffer.push(generator.enums.c.symbol.true);
								}
								else if (line.values[j] == generator.enums.python.symbol.false) {
                                    contentBuffer.push(generator.enums.c.symbol.false);
								}
								else if (line.values[j] == generator.enums.python.symbol.not) {
                                    contentBuffer.push(generator.enums.c.symbol.not);
								}
								else if (line.values[j] == generator.enums.python.symbol.and) {
                                    contentBuffer.push(generator.enums.c.symbol.and);
								}
								else if (line.values[j] == generator.enums.python.symbol.or) {
                                    contentBuffer.push(generator.enums.c.symbol.or);
								}

							}
							else if (line.tokens[j] == generator.enums.token.stringConstant) {

								contentBuffer.push(line.values[j]);
							}
							else if (line.tokens[j] == generator.enums.token.symbol) {

								var pushToBuffer = false;

								if (line.values[j] == generator.enums.symbol.leftParenthesis) {

									if (stack.count > 0) {
										if (!((line.values[j - 1] == generator.enums.c.data.type.integer ||
											line.values[j - 1] == generator.enums.python.data.type.float ||
											line.values[j - 1] == generator.enums.python.symbol.string) ||
											line.tokens[j - 1] == generator.enums.token.keyword)) {
											pushToBuffer = true;
											stack.set++;
										}
									}
									else {
										pushToBuffer = true;
									}
								}
								else if (line.values[j] == generator.enums.symbol.rightParenthesis) {

									if (stack.set > 0) {
										stack.set--;
									}

									if (stack.count == 0) {
										pushToBuffer = true;
									}

									if (stack.set == 0 && stack.count > 0) {

										stack.count--;
										var parseDataTypeChange = false;
										var currentFunction = stack.functionName.pop();
										var currentContentBuffer = stack.content.pop();

										var tmpEquation = currentContentBuffer.data.slice();

										for (var k = 0; k < tmpEquation.length; k++) {

											if (tmpEquation[k].search("intValue") != -1) {

												tmpEquation[k] = tmpEquation[k].substring(1).replace(RegExp('\\b' + ".intValue" + '\\b','g'), "");
											}
											else if (tmpEquation[k].search("intValue") != -1) {
												tmpEquation[k] = tmpEquation[k].substring(1).replace(RegExp('\\b' + ".floatValue" + '\\b','g'), "");
											}
											else if (tmpEquation[k].search("charValue") != -1) {
												tmpEquation[k] = tmpEquation[k].replace(RegExp('\\b' + ".charValue" + '\\b','g'), "");
											}
										}

										var operationType = isEquation(tmpEquation.join(" "));
										try {

											if (variable.name == generator.refactor.getVariable(tmpEquation.join(" ")).name) {
												parseDataTypeChange = true;
												operationType = previousVariable.type;
												generator.refactor.typeChangeCount++;
												var tmpValueHolder = clone.variable(previousVariable);
												tmpValueHolder.ambiguous = false;
												tmpValueHolder.name = "__tmp__valueHolder_" + previousVariable.name + generator.refactor.typeChangeCount;
												generator.refactor.insertVariable(tmpValueHolder);

												line.contentStack.unshift("strcpy(" + tmpValueHolder.name + ", " + previousVariable.name + ".charValue)");
												line.contentStack.unshift(generator.enums.c.symbol.string + " __tmp__valueHolder_" + previousVariable.name + generator.refactor.typeChangeCount + " = ( char * ) calloc(2048, sizeof( char ) )");
												generator.headers.insert("string.h");

												for (var k = 0; k < contentBuffer.length; k++) {
													if (contentBuffer[k] == variable.name) {
														contentBuffer[k] = "(*" + variable.name + "." + variable.type + "Value)";
													}
												}
											}
										}
										catch (exception) {

										}
										//alert(operationType + "-" + currentFunction + " = " + currentContentBuffer.data.join(" "));
										if (operationType == generator.enums.c.data.type.string) {

											var list;
											var candidate;
											var result = "";

											if (currentFunction == generator.enums.c.data.type.integer) {

												if (currentContentBuffer.data.length > 1) {
													//alert(currentContentBuffer.data.join(","));
													for (var k = 0; k < currentContentBuffer.data.length; k++) {
														if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
															currentContentBuffer.data.splice(k, 1);
															k--;
														}
													}

													list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
													result = candidate.function(currentContentBuffer.data);

													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.integer, 3);
													result = candidate.function(result);
												}
												else {
													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.integer, 3);

													if (parseDataTypeChange) {
														currentContentBuffer.data[0] = "__tmp__valueHolder_" + previousVariable.name + generator.refactor.typeChangeCount;
													}

													result = candidate.function(currentContentBuffer.data);
												}
											}
											else if (currentFunction == generator.enums.python.data.type.float) {

												if (currentContentBuffer.data.length > 1) {

													for (var k = 0; k < currentContentBuffer.data.length; k++) {
														if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
															currentContentBuffer.data.splice(k, 1);
															k--;
														}
													}

													list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
													result = candidate.function(currentContentBuffer.data);

													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
													result = candidate.function(result);
												}
												else {
													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
													
													if (parseDataTypeChange) {
														currentContentBuffer.data[0] = "__tmp__valueHolder_" + previousVariable.name + generator.refactor.typeChangeCount;
													}

													result = candidate.function(currentContentBuffer.data);
												}

											}
											else if (currentFunction == generator.enums.python.symbol.string) {

												for (var k = 0; k < currentContentBuffer.data.length; k++) {
													if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
														currentContentBuffer.data.splice(k, 1);
														k--;
													}
												}

												list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data);
											}
											else {
												// Function Analyser here
												try {

													var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
													result = candidate.function(currentContentBuffer.data);

												}
												catch (exception) {

													if (exception === dictionary.search.exception.NoEquivalent) {

														try {

                                                            var func = generator.refactor.getFunction(currentFunction);
                                                            var candidate = generator.c.to.python.processUserDefinedFunction(buffer, func, currentContentBuffer.data);


                                                            var parameters = generator.functions.search(candidate.name).param;
                                                            parameters = parameters.split(", ");

                                                            for (var k = 0; k < parameters.length; k++) {

                                                                var bufferParameterType = isEquation(currentContentBuffer.data[k]);
                                                                var currentParameter = parameters[k].split(" ");
                                                                var incompatible = false;

                                                                if (currentParameter[0] == "ambiguous") {
                                                                    if (bufferParameterType != "ambiguous") {
                                                                        incompatible = true;
                                                                    }
                                                                }

                                                                if (incompatible) {

                                                                    generator.refactor.paramMDCount++;
                                                                    var initializeString = ["", "", ""];
                                                                    initializeString[0] = "ambiguous __param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    generator.includer.function.memory.gc();
                                                                    var tmpVar = new Variable("__param__init__" + currentParameter[1] + generator.refactor.paramMDCount, bufferParameterType, i);
                                                                    if (definitionStack.length > 0) {

                                                                        tmpVar.temporary = true;
                                                                        var exist = false;

                                                                        for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

                                                                            if (definitionStack[definitionStack.length - 1].variables[j] == tmpVar.name) {
                                                                                insideParameter = true;
                                                                                exist = true;
                                                                                break;
                                                                            }
                                                                        }

                                                                        if (!exist) {
                                                                            definitionStack[definitionStack.length - 1].variables.push(tmpVar.name);
                                                                        }
                                                                    }

                                                                    generator.refactor.insertVariable(tmpVar);

                                                                    if (bufferParameterType == generator.enums.c.data.type.string) {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue = ";
                                                                        initializeString[1]+= "( char * ) calloc(2048, sizeof( char ) )";
                                                                        initializeString[2]+= "sprintf(__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue, " + currentContentBuffer.data[k] + ")";
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    }
                                                                    else {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType + "Value = ";
                                                                        initializeString[1]+= "( " + bufferParameterType + " * ) calloc(1, sizeof( " + bufferParameterType + " ) )";
                                                                        initializeString[2]+= "(*__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType  + "Value"+ ") = ";
                                                                        initializeString[2]+= currentContentBuffer.data[k];
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount
                                                                    }

                                                                    for (var l = 0; l < 3; l++) {
                                                                        if (stack.content.length == 0) {
                                                                            line.contentStack.push(initializeString[l]);
                                                                        }
                                                                        else {
                                                                            stack.content[stack.content.length - 1].data.push(initializeString[l]);
                                                                        }
                                                                    }
                                                                }
                                                            }

                                                            result = candidate.function(currentContentBuffer.data);
                                                        }
                                                        catch (innerException) {

                                                            throw innerException;
                                                        }
													}
												}
											}
										}
										else if (operationType == generator.enums.c.data.type.integer) {

											var list;
											var candidate;
											var result = "";

											if (currentFunction == generator.enums.c.data.type.integer) {
												result = currentContentBuffer.data.join(" ");
											}
											else if (currentFunction == generator.enums.python.data.type.float) {
												result = "((" + generator.enums.c.data.type.float + ")(" + currentContentBuffer.data.join(" ") + "))";
											}
											else if (currentFunction == generator.enums.python.symbol.string) {
												list = dictionary.pages.findWordsByKeywords(["integer-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data.join(" "));
											}
											else {
												//alert(currentContentBuffer.data.join("-"));
												try {

													var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
													result = candidate.function(currentContentBuffer.data);

												}
												catch (exception) {

													if (exception === dictionary.search.exception.NoEquivalent) {

														try {

                                                            var func = generator.refactor.getFunction(currentFunction);
                                                            var candidate = generator.c.to.python.processUserDefinedFunction(buffer, func, currentContentBuffer.data);


                                                            var parameters = generator.functions.search(candidate.name).param;
                                                            parameters = parameters.split(", ");

                                                            for (var k = 0; k < parameters.length; k++) {

                                                                var bufferParameterType = isEquation(currentContentBuffer.data[k]);
                                                                var currentParameter = parameters[k].split(" ");
                                                                var incompatible = false;

                                                                if (currentParameter[0] == "ambiguous") {
                                                                    if (bufferParameterType != "ambiguous") {
                                                                        incompatible = true;
                                                                    }
                                                                }

                                                                if (incompatible) {

                                                                    generator.refactor.paramMDCount++;
                                                                    var initializeString = ["", "", ""];
                                                                    initializeString[0] = "ambiguous __param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    generator.includer.function.memory.gc();
                                                                    var tmpVar = new Variable("__param__init__" + currentParameter[1] + generator.refactor.paramMDCount, bufferParameterType, i);
                                                                    if (definitionStack.length > 0) {

                                                                        tmpVar.temporary = true;
                                                                        var exist = false;

                                                                        for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

                                                                            if (definitionStack[definitionStack.length - 1].variables[j] == tmpVar.name) {
                                                                                insideParameter = true;
                                                                                exist = true;
                                                                                break;
                                                                            }
                                                                        }

                                                                        if (!exist) {
                                                                            definitionStack[definitionStack.length - 1].variables.push(tmpVar.name);
                                                                        }
                                                                    }

                                                                    generator.refactor.insertVariable(tmpVar);

                                                                    if (bufferParameterType == generator.enums.c.data.type.string) {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue = ";
                                                                        initializeString[1]+= "( char * ) calloc(2048, sizeof( char ) )";
                                                                        initializeString[2]+= "sprintf(__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue, " + currentContentBuffer.data[k] + ")";
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    }
                                                                    else {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType + "Value = ";
                                                                        initializeString[1]+= "( " + bufferParameterType + " * ) calloc(1, sizeof( " + bufferParameterType + " ) )";
                                                                        initializeString[2]+= "(*__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType  + "Value"+ ") = ";
                                                                        initializeString[2]+= currentContentBuffer.data[k];
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount
                                                                    }

                                                                    for (var l = 0; l < 3; l++) {
                                                                        if (stack.content.length == 0) {
                                                                            line.contentStack.push(initializeString[l]);
                                                                        }
                                                                        else {
                                                                            stack.content[stack.content.length - 1].data.push(initializeString[l]);
                                                                        }
                                                                    }
                                                                }
                                                            }

                                                            result = candidate.function(currentContentBuffer.data);
                                                        }
                                                        catch (innerException) {

                                                            throw innerException;
                                                        }
													}
												}
											}
										}
										else if (operationType == generator.enums.c.data.type.float) {

											var list;
											var candidate;
											var result = "";
											if (currentFunction == generator.enums.c.data.type.integer) {
												result = "((" + generator.enums.c.data.type.integer + ")(" + currentContentBuffer.data.join(" ") + "))";
											}
											else if (currentFunction == generator.enums.symbol.float) {
												result = currentContentBuffer.data.join(" ");
											}
											else if (currentFunction == generator.enums.python.symbol.string) {

												list = dictionary.pages.findWordsByKeywords(["float-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data.join(" "));
											}
											else {
												// Function Analyser here
												try {

													var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
													result = candidate.function(currentContentBuffer.data);

												}
												catch (exception) {

													if (exception === dictionary.search.exception.NoEquivalent) {

														try {

                                                            var func = generator.refactor.getFunction(currentFunction);
                                                            var candidate = generator.c.to.python.processUserDefinedFunction(buffer, func, currentContentBuffer.data);


                                                            var parameters = generator.functions.search(candidate.name).param;
                                                            parameters = parameters.split(", ");

                                                            for (var k = 0; k < parameters.length; k++) {

                                                                var bufferParameterType = isEquation(currentContentBuffer.data[k]);
                                                                var currentParameter = parameters[k].split(" ");
                                                                var incompatible = false;

                                                                if (currentParameter[0] == "ambiguous") {
                                                                    if (bufferParameterType != "ambiguous") {
                                                                        incompatible = true;
                                                                    }
                                                                }

                                                                if (incompatible) {

                                                                    generator.refactor.paramMDCount++;
                                                                    var initializeString = ["", "", ""];
                                                                    initializeString[0] = "ambiguous __param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    generator.includer.function.memory.gc();
                                                                    var tmpVar = new Variable("__param__init__" + currentParameter[1] + generator.refactor.paramMDCount, bufferParameterType, i);
                                                                    if (definitionStack.length > 0) {

                                                                        tmpVar.temporary = true;
                                                                        var exist = false;

                                                                        for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

                                                                            if (definitionStack[definitionStack.length - 1].variables[j] == tmpVar.name) {
                                                                                insideParameter = true;
                                                                                exist = true;
                                                                                break;
                                                                            }
                                                                        }

                                                                        if (!exist) {
                                                                            definitionStack[definitionStack.length - 1].variables.push(tmpVar.name);
                                                                        }
                                                                    }

                                                                    generator.refactor.insertVariable(tmpVar);

                                                                    if (bufferParameterType == generator.enums.c.data.type.string) {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue = ";
                                                                        initializeString[1]+= "( char * ) calloc(2048, sizeof( char ) )";
                                                                        initializeString[2]+= "sprintf(__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue, " + currentContentBuffer.data[k] + ")";
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    }
                                                                    else {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType + "Value = ";
                                                                        initializeString[1]+= "( " + bufferParameterType + " * ) calloc(1, sizeof( " + bufferParameterType + " ) )";
                                                                        initializeString[2]+= "(*__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType  + "Value"+ ") = ";
                                                                        initializeString[2]+= currentContentBuffer.data[k];
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount
                                                                    }

                                                                    for (var l = 0; l < 3; l++) {
                                                                        if (stack.content.length == 0) {
                                                                            line.contentStack.push(initializeString[l]);
                                                                        }
                                                                        else {
                                                                            stack.content[stack.content.length - 1].data.push(initializeString[l]);
                                                                        }
                                                                    }
                                                                }
                                                            }

                                                            result = candidate.function(currentContentBuffer.data);
                                                        }
                                                        catch (innerException) {

                                                            throw innerException;
                                                        }
													}
												}
											}
										}
										else {
											try {

												var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
												result = candidate.function(currentContentBuffer.data);

											}
											catch (exception) {

												if (exception === dictionary.search.exception.NoEquivalent) {

													try {

                                                        var func = generator.refactor.getFunction(currentFunction);
                                                        var candidate = generator.c.to.python.processUserDefinedFunction(buffer, func, currentContentBuffer.data);


                                                        var parameters = generator.functions.search(candidate.name).param;
                                                        parameters = parameters.split(", ");

                                                        for (var k = 0; k < parameters.length; k++) {

                                                            var bufferParameterType = isEquation(currentContentBuffer.data[k]);
                                                            var currentParameter = parameters[k].split(" ");
                                                            var incompatible = false;

                                                            if (currentParameter[0] == "ambiguous") {
                                                                if (bufferParameterType != "ambiguous") {
                                                                    incompatible = true;
                                                                }
                                                            }

                                                            if (incompatible) {

                                                                generator.refactor.paramMDCount++;
                                                                var initializeString = ["", "", ""];
                                                                initializeString[0] = "ambiguous __param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                generator.includer.function.memory.gc();
                                                                var tmpVar = new Variable("__param__init__" + currentParameter[1] + generator.refactor.paramMDCount, bufferParameterType, i);
                                                                if (definitionStack.length > 0) {

                                                                    tmpVar.temporary = true;
                                                                    var exist = false;

                                                                    for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

                                                                        if (definitionStack[definitionStack.length - 1].variables[j] == tmpVar.name) {
                                                                            insideParameter = true;
                                                                            exist = true;
                                                                            break;
                                                                        }
                                                                    }

                                                                    if (!exist) {
                                                                        definitionStack[definitionStack.length - 1].variables.push(tmpVar.name);
                                                                    }
                                                                }

                                                                generator.refactor.insertVariable(tmpVar);

                                                                if (bufferParameterType == generator.enums.c.data.type.string) {
                                                                    initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue = ";
                                                                    initializeString[1]+= "( char * ) calloc(2048, sizeof( char ) )";
                                                                    initializeString[2]+= "sprintf(__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue, " + currentContentBuffer.data[k] + ")";
                                                                    currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                }
                                                                else {
                                                                    initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType + "Value = ";
                                                                    initializeString[1]+= "( " + bufferParameterType + " * ) calloc(1, sizeof( " + bufferParameterType + " ) )";
                                                                    initializeString[2]+= "(*__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType  + "Value"+ ") = ";
                                                                    initializeString[2]+= currentContentBuffer.data[k];
                                                                    currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount
                                                                }

                                                                for (var l = 0; l < 3; l++) {
                                                                    if (stack.content.length == 0) {
                                                                        line.contentStack.push(initializeString[l]);
                                                                    }
                                                                    else {
                                                                        stack.content[stack.content.length - 1].data.push(initializeString[l]);
                                                                    }
                                                                }
                                                            }
                                                        }

                                                        result = candidate.function(currentContentBuffer.data);
                                                    }
                                                    catch (innerException) {

                                                        throw innerException;
                                                    }
												}
											}
										}

										if (stack.content.length == 0) {
											currentContentBuffer.result += result;
											contentBuffer.push(currentContentBuffer.result);
										}
										else {

											stack.content[stack.content.length - 1].data.push(result);
										}
									}

								}
								else if (line.values[j] == generator.enums.python.symbol.exponent) {
									exponent = true;
								}
								else if (line.values[j] == generator.enums.python.symbol.floorDivision) {
									floor = true;
								}
								else {
									pushToBuffer = true;
								}

								if (pushToBuffer) {
									contentBuffer.push(line.values[j]);
								}
							}
							else if (line.tokens[j] == generator.enums.token.keyword) {
								if (j + 1 != line.tokens.length) {
									if (line.values[j + 1] == generator.enums.symbol.leftParenthesis) {
										stack.count += 1;
										stack.functionName.push(line.values[j]);
										stack.content.push(new StackContent());
									}
								}
							}
							else if (line.tokens[j] == generator.enums.token.comment) {

                                var currentIndex 	= line.values[j].replace(/[^0-9.]/g, '');
                                contentBuffer.push("/*" + tokenizer.token.comment[currentIndex - 1].value + "*/");
							}

							if (stack.count > 0) {

								for (var k = lastContent.length; k < contentBuffer.length; k++) {

									stack.pushData(contentBuffer[k]);
								}

								contentBuffer = lastContent;
							}
						}
						//
						var content = "";
						for (var j = 0; j < contentBuffer.length; j++) {
							content += trimString(contentBuffer[j]);
							if (j + 1 < contentBuffer.length) {
								content += " ";
							}
						}

						if (!isStr)
							line.contentStack.push(content);
					}

					if (isStr && legal) {

						contentBuffer = [];
						var lastContent = "";
						var previousVariable = "";
						var stack = new ParenthesisStack();

						variable.type = generator.enums.c.data.type.string;
						generator.headers.insert("stdio.h");
						generator.headers.insert("stdlib.h");

						if (!newDeclaration) {

							if (definitionStack.length > 0) {

								definitionStack[definitionStack.length - 1].original.push(variable);
								if (definitionStack[definitionStack.length - 1].definitionType == generator.enums.definition.function) {

									newDeclaration = true;
									generator.refactor.removeVariable(variable.name);
								}
							}
							else {

								generator.c.to.python.refactor(variable, buffer);
								if (variable.ambiguous) {

									if (generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type != variable.type) {

										var fcontent = "";
										var content = "";
										var allocContent = "";

										if (generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type == generator.enums.c.data.type.string) {

											fcontent += generator.refactor.variableList[generator.refactor.findVariable(variable.name)].name + ".charValue";
										}
										else {

											fcontent += generator.refactor.variableList[generator.refactor.findVariable(variable.name)].name + "." + generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type + "Value";
										}

										if (variable.type == generator.enums.c.data.type.string) {

											allocContent = "( char * ) calloc(2048, sizeof( char ) )";
											content += generator.refactor.variableList[generator.refactor.findVariable(variable.name)].name + ".charValue";
										}
										else {

											allocContent = "( " + variable.type + " * ) calloc(1, sizeof( " + variable.type + " ) )";
											content += "*" + variable.name + "." + variable.type + "Value";
										}

										line.contentStack.push("free(" + fcontent + ")");
										line.contentStack.push(content + " = " + allocContent);
									}
								}

								previousVariable = generator.refactor.variableList[generator.refactor.findVariable(variable.name)];
								generator.refactor.variableList[generator.refactor.findVariable(variable.name)] = variable;
							}
						}

						if (newDeclaration) {

							var insideParameter = false;
							if (definitionStack.length > 0) {

								variable.temporary = true;
								var exist = false;

								for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

									if (definitionStack[definitionStack.length - 1].variables[j] == variable.name) {
										insideParameter = true;
										exist = true;
										break;
									}
								}

								if (!exist) {
									definitionStack[definitionStack.length - 1].variables.push(variable.name);
								}
							}

							generator.refactor.insertVariable(variable);

							if (!insideParameter) {

								line.contentStack.push("char *" + variable.name + " = " + " ( char * ) calloc(2048, sizeof( char ))");
							}
						}

						action.pushVariableState(variable);
						line.actionStack.push(action);

						var exponent = false;
						var floor = false;
						var stack = new ParenthesisStack();
						contentBuffer = [];
						var lastContent = "";
						for (var j = 0; j < line.tokens.length; j++) {

							lastContent = contentBuffer.slice();

							if (line.tokens[j] == generator.enums.token.constant) {
								try {

									var constantValue = "";
									if (!isInteger(line.values[j])) {
										if (generator.options.useDoubleInsteadOfFloat) {
											constantValue += line.values[j];
										}
										else {
											constantValue += line.values[j] + "f";
										}
									}
									else {
										constantValue += line.values[j];
									}

									if (exponent) {
										exponent = false;
										var prevValue = "";
										if (stack.count > 0) {
											prevValue = stack.content[stack.content.length - 1].data.pop();
										}
										else {
											prevValue = contentBuffer.pop();
										}
										var parameter = [prevValue, ",", constantValue];
										var list = dictionary.pages.findWordsByKeywords(["math-operation", "exponent", "C-language"]);
										var candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
										contentBuffer.push(candidate.function(parameter));
									}
									else if (floor) {
										floor = false;
									}
									else {
										contentBuffer.push(constantValue);
									}
								}
								catch (exception) {

									legal = false;
								}
							}
							else if (line.tokens[j] == generator.enums.token.identifier) {

								var identifier = null;
								for (var k = 0; k < line.actionStack.length; k++) {

									for (var l = 0; l < line.actionStack[k].state.length; l++) {

										if (line.values[j] == line.actionStack[k].state[l].name) {

											identifier = line.actionStack[k].state[l];
											break;
										}
									}
								}

								if (identifier != null) {

									if (identifier.lineDeclared != i && j != 0) {

										if (identifier.type != variable.type && stack.count == 0) {

											if (variable.type == generator.enums.c.data.type.integer ||
												variable.type == generator.enums.c.data.type.float) {
												contentBuffer.push("(" + variable.type + ")");
											}
											else if (identifier.type == generator.enums.c.data.type.string) {

												if (variable.type == generator.enums.c.data.type.integer) {
													generator.includer.function.parser.integer.string();
												}
												else if (variable.type == generator.enums.c.data.type.float) {
													generator.includer.function.parser.float.string();
												}
											}
										}
									}

									if (identifier.ambiguous) {
										if (identifier.type == generator.enums.c.data.type.string) {
											contentBuffer.push(identifier.name + ".charValue");
										}
										else {
											contentBuffer.push("(*" + identifier.name+ "." + identifier.type + "Value)");
										}
									}
									else {
										contentBuffer.push(identifier.name);
									}
								}

							}
							else if (line.tokens[j] == generator.enums.token.reserveWord) {

								if (line.values[j] == generator.enums.c.data.type.integer ||
									line.values[j] == generator.enums.python.data.type.float ||
									line.values[j] == generator.enums.python.symbol.string) {
									if (j + 1 != line.tokens.length) {
										if (line.values[j + 1] == generator.enums.symbol.leftParenthesis) {
											stack.count += 1;
											stack.functionName.push(line.values[j]);
											stack.content.push(new StackContent());
										}
									}
								}
								else if (line.values[j] == generator.enums.python.symbol.true) {
                                    contentBuffer.push(generator.enums.c.symbol.true);
								}
								else if (line.values[j] == generator.enums.python.symbol.false) {
                                    contentBuffer.push(generator.enums.c.symbol.false);
								}
								else if (line.values[j] == generator.enums.python.symbol.not) {
                                    contentBuffer.push(generator.enums.c.symbol.not);
								}
								else if (line.values[j] == generator.enums.python.symbol.and) {
                                    contentBuffer.push(generator.enums.c.symbol.and);
								}
								else if (line.values[j] == generator.enums.python.symbol.or) {
                                    contentBuffer.push(generator.enums.c.symbol.or);
								}

							}
							else if (line.tokens[j] == generator.enums.token.stringConstant) {

								contentBuffer.push(line.values[j]);
							}
							else if (line.tokens[j] == generator.enums.token.symbol) {

								var pushToBuffer = false;

								if (line.values[j] == generator.enums.symbol.leftParenthesis) {

									if (stack.count > 0) {
										if (!((line.values[j - 1] == generator.enums.c.data.type.integer ||
											line.values[j - 1] == generator.enums.python.data.type.float ||
											line.values[j - 1] == generator.enums.python.symbol.string) ||
											line.tokens[j - 1] == generator.enums.token.keyword)) {
											pushToBuffer = true;
											stack.set++;
										}
									}
									else {
										pushToBuffer = true;
									}
								}
								else if (line.values[j] == generator.enums.symbol.rightParenthesis) {

									if (stack.set > 0) {
										stack.set--;
									}

									if (stack.count == 0) {
										pushToBuffer = true;
									}

									if (stack.set == 0 && stack.count > 0) {

										stack.count--;
										var parseDataTypeChange = false;
										var currentFunction = stack.functionName.pop();
										var currentContentBuffer = stack.content.pop();

										var tmpEquation = currentContentBuffer.data.slice();

										for (var k = 0; k < tmpEquation.length; k++) {

											if (tmpEquation[k].search("intValue") != -1) {

												tmpEquation[k] = tmpEquation[k].substring(1).replace(RegExp('\\b' + ".intValue" + '\\b','g'), "");
											}
											else if (tmpEquation[k].search("intValue") != -1) {
												tmpEquation[k] = tmpEquation[k].substring(1).replace(RegExp('\\b' + ".floatValue" + '\\b','g'), "");
											}
											else if (tmpEquation[k].search("charValue") != -1) {
												tmpEquation[k] = tmpEquation[k].replace(RegExp('\\b' + ".charValue" + '\\b','g'), "");
											}
										}

										var operationType = isEquation(tmpEquation.join(" "));
										try {

											if (variable.name == generator.refactor.getVariable(tmpEquation.join(" ")).name) {
												parseDataTypeChange = true;
												operationType = previousVariable.type;
												generator.refactor.typeChangeCount++;
												line.contentStack.unshift(previousVariable.type + " __tmp__valueHolder_" + previousVariable.name + generator.refactor.typeChangeCount + " = (*" + previousVariable.name + "." + previousVariable.type + "Value)");
												var tmpValueHolder = clone.variable(previousVariable);
												tmpValueHolder.ambiguous = false;
												tmpValueHolder.name = "__tmp__valueHolder_" + previousVariable.name + generator.refactor.typeChangeCount;
												generator.refactor.insertVariable(tmpValueHolder);
											}
										}
										catch (exception) {

										}
										
										//alert(operationType + "-" + currentFunction + " = " + currentContentBuffer.data.join(" "));
										if (operationType == generator.enums.c.data.type.string) {

											var list;
											var candidate;
											var result = "";

											if (currentFunction == generator.enums.c.data.type.integer) {

												if (currentContentBuffer.data.length > 1) {
													//alert(currentContentBuffer.data.join(","));
													for (var k = 0; k < currentContentBuffer.data.length; k++) {
														if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
															currentContentBuffer.data.splice(k, 1);
															k--;
														}
													}

													list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
													result = candidate.function(currentContentBuffer.data);

													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.integer, 3);
													result = candidate.function(result);
												}
												else {
													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.integer, 3);
													result = candidate.function(currentContentBuffer.data);
												}
											}
											else if (currentFunction == generator.enums.python.data.type.float) {

												if (currentContentBuffer.data.length > 1) {

													for (var k = 0; k < currentContentBuffer.data.length; k++) {
														if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
															currentContentBuffer.data.splice(k, 1);
															k--;
														}
													}

													list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
													result = candidate.function(currentContentBuffer.data);

													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
													result = candidate.function(result);
												}
												else {
													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
													result = candidate.function(currentContentBuffer.data);
												}

											}
											else if (currentFunction == generator.enums.python.symbol.string) {

												for (var k = 0; k < currentContentBuffer.data.length; k++) {
													if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
														currentContentBuffer.data.splice(k, 1);
														k--;
													}
												}

												list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data);
											}
											else {
												// Function Analyser here
												try {

													var func = generator.refactor.getFunction(currentFunction);
													var candidate = generator.c.to.python.processUserDefinedFunction(buffer, func, currentContentBuffer.data);


                                                    var parameters = generator.functions.search(candidate.name).param;
                                                    parameters = parameters.split(", ");

                                                    for (var k = 0; k < parameters.length; k++) {

                                                        var bufferParameterType = isEquation(currentContentBuffer.data[k]);
                                                        var currentParameter = parameters[k].split(" ");
                                                        var incompatible = false;

                                                        if (currentParameter[0] == "ambiguous") {
                                                            if (bufferParameterType != "ambiguous") {
                                                                incompatible = true;
                                                            }
                                                        }

                                                        if (incompatible) {

                                                            generator.refactor.paramMDCount++;
                                                            var initializeString = ["", "", ""];
                                                            initializeString[0] = "ambiguous __param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                            generator.includer.function.memory.gc();
                                                            var tmpVar = new Variable("__param__init__" + currentParameter[1] + generator.refactor.paramMDCount, bufferParameterType, i);
                                                            if (definitionStack.length > 0) {

                                                                tmpVar.temporary = true;
                                                                var exist = false;

                                                                for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

                                                                    if (definitionStack[definitionStack.length - 1].variables[j] == tmpVar.name) {
                                                                        insideParameter = true;
                                                                        exist = true;
                                                                        break;
                                                                    }
                                                                }

                                                                if (!exist) {
                                                                    definitionStack[definitionStack.length - 1].variables.push(tmpVar.name);
                                                                }
                                                            }

                                                            generator.refactor.insertVariable(tmpVar);

                                                            if (bufferParameterType == generator.enums.c.data.type.string) {
                                                                initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue = ";
                                                                initializeString[1]+= "( char * ) calloc(2048, sizeof( char ) )";
                                                                initializeString[2]+= "sprintf(__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue, " + currentContentBuffer.data[k] + ")";
                                                                currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                            }
                                                            else {
                                                                initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType + "Value = ";
                                                                initializeString[1]+= "( " + bufferParameterType + " * ) calloc(1, sizeof( " + bufferParameterType + " ) )";
                                                                initializeString[2]+= "(*__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType  + "Value"+ ") = ";
                                                                initializeString[2]+= currentContentBuffer.data[k];
                                                                currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount
                                                            }

                                                            for (var l = 0; l < 3; l++) {
                                                                if (stack.content.length == 0) {
                                                                    line.contentStack.push(initializeString[l]);
                                                                }
                                                                else {
                                                                    stack.content[stack.content.length - 1].data.push(initializeString[l]);
                                                                }
                                                            }
                                                        }
                                                    }

                                                    result = candidate.function(currentContentBuffer.data);
												}
												catch (innerException) {

													throw innerException;
												}
											}
										}
										else if (operationType == generator.enums.c.data.type.integer || operationType == generator.enums.c.data.type.float) {

											var list;
											var candidate;
											var result = "";

											if (currentFunction == generator.enums.c.data.type.integer) {
												result = currentContentBuffer.data.join(" ");
											}
											else if (currentFunction == generator.enums.python.data.type.float) {
												result = currentContentBuffer.data.join(" ");
											}
											else if (currentFunction == generator.enums.python.symbol.string) {
												result = currentContentBuffer.data.join(" ");
												if (parseDataTypeChange) {
													result = "__tmp__valueHolder_" + previousVariable.name + generator.refactor.typeChangeCount + "";
												}
											}
											else {
												//alert(currentContentBuffer.data.join("-"));
												try {

													var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
													result = candidate.function(currentContentBuffer.data);

												}
												catch (exception) {

													if (exception === dictionary.search.exception.NoEquivalent) {

														try {

                                                            var func = generator.refactor.getFunction(currentFunction);
                                                            var candidate = generator.c.to.python.processUserDefinedFunction(buffer, func, currentContentBuffer.data);


                                                            var parameters = generator.functions.search(candidate.name).param;
                                                            parameters = parameters.split(", ");

                                                            for (var k = 0; k < parameters.length; k++) {

                                                                var bufferParameterType = isEquation(currentContentBuffer.data[k]);
                                                                var currentParameter = parameters[k].split(" ");
                                                                var incompatible = false;

                                                                if (currentParameter[0] == "ambiguous") {
                                                                    if (bufferParameterType != "ambiguous") {
                                                                        incompatible = true;
                                                                    }
                                                                }

                                                                if (incompatible) {

                                                                    generator.refactor.paramMDCount++;
                                                                    var initializeString = ["", "", ""];
                                                                    initializeString[0] = "ambiguous __param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    generator.includer.function.memory.gc();
                                                                    var tmpVar = new Variable("__param__init__" + currentParameter[1] + generator.refactor.paramMDCount, bufferParameterType, i);
                                                                    if (definitionStack.length > 0) {

                                                                        tmpVar.temporary = true;
                                                                        var exist = false;

                                                                        for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

                                                                            if (definitionStack[definitionStack.length - 1].variables[j] == tmpVar.name) {
                                                                                insideParameter = true;
                                                                                exist = true;
                                                                                break;
                                                                            }
                                                                        }

                                                                        if (!exist) {
                                                                            definitionStack[definitionStack.length - 1].variables.push(tmpVar.name);
                                                                        }
                                                                    }

                                                                    generator.refactor.insertVariable(tmpVar);

                                                                    if (bufferParameterType == generator.enums.c.data.type.string) {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue = ";
                                                                        initializeString[1]+= "( char * ) calloc(2048, sizeof( char ) )";
                                                                        initializeString[2]+= "sprintf(__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue, " + currentContentBuffer.data[k] + ")";
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                    }
                                                                    else {
                                                                        initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType + "Value = ";
                                                                        initializeString[1]+= "( " + bufferParameterType + " * ) calloc(1, sizeof( " + bufferParameterType + " ) )";
                                                                        initializeString[2]+= "(*__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType  + "Value"+ ") = ";
                                                                        initializeString[2]+= currentContentBuffer.data[k];
                                                                        currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount
                                                                    }

                                                                    for (var l = 0; l < 3; l++) {
                                                                        if (stack.content.length == 0) {
                                                                            line.contentStack.push(initializeString[l]);
                                                                        }
                                                                        else {
                                                                            stack.content[stack.content.length - 1].data.push(initializeString[l]);
                                                                        }
                                                                    }
                                                                }
                                                            }

                                                            result = candidate.function(currentContentBuffer.data);
                                                        }
                                                        catch (innerException) {

                                                            throw innerException;
                                                        }
													}
												}
											}
										}
										else {

											try {

												var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
												result = candidate.function(currentContentBuffer.data);

											}
											catch (exception) {

												if (exception === dictionary.search.exception.NoEquivalent) {

													try {

                                                        var func = generator.refactor.getFunction(currentFunction);
                                                        var candidate = generator.c.to.python.processUserDefinedFunction(buffer, func, currentContentBuffer.data);


                                                        var parameters = generator.functions.search(candidate.name).param;
                                                        parameters = parameters.split(", ");

                                                        for (var k = 0; k < parameters.length; k++) {

                                                            var bufferParameterType = isEquation(currentContentBuffer.data[k]);
                                                            var currentParameter = parameters[k].split(" ");
                                                            var incompatible = false;

                                                            if (currentParameter[0] == "ambiguous") {
                                                                if (bufferParameterType != "ambiguous") {
                                                                    incompatible = true;
                                                                }
                                                            }

                                                            if (incompatible) {

                                                                generator.refactor.paramMDCount++;
                                                                var initializeString = ["", "", ""];
                                                                initializeString[0] = "ambiguous __param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                generator.includer.function.memory.gc();
                                                                var tmpVar = new Variable("__param__init__" + currentParameter[1] + generator.refactor.paramMDCount, bufferParameterType, i);
                                                                if (definitionStack.length > 0) {

                                                                    tmpVar.temporary = true;
                                                                    var exist = false;

                                                                    for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

                                                                        if (definitionStack[definitionStack.length - 1].variables[j] == tmpVar.name) {
                                                                            insideParameter = true;
                                                                            exist = true;
                                                                            break;
                                                                        }
                                                                    }

                                                                    if (!exist) {
                                                                        definitionStack[definitionStack.length - 1].variables.push(tmpVar.name);
                                                                    }
                                                                }

                                                                generator.refactor.insertVariable(tmpVar);

                                                                if (bufferParameterType == generator.enums.c.data.type.string) {
                                                                    initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue = ";
                                                                    initializeString[1]+= "( char * ) calloc(2048, sizeof( char ) )";
                                                                    initializeString[2]+= "sprintf(__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + ".charValue, " + currentContentBuffer.data[k] + ")";
                                                                    currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount;
                                                                }
                                                                else {
                                                                    initializeString[1] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType + "Value = ";
                                                                    initializeString[1]+= "( " + bufferParameterType + " * ) calloc(1, sizeof( " + bufferParameterType + " ) )";
                                                                    initializeString[2]+= "(*__param__init__" + currentParameter[1] + generator.refactor.paramMDCount + "." + bufferParameterType  + "Value"+ ") = ";
                                                                    initializeString[2]+= currentContentBuffer.data[k];
                                                                    currentContentBuffer.data[k] = "__param__init__" + currentParameter[1] + generator.refactor.paramMDCount
                                                                }

                                                                for (var l = 0; l < 3; l++) {
                                                                    if (stack.content.length == 0) {
                                                                        line.contentStack.push(initializeString[l]);
                                                                    }
                                                                    else {
                                                                        stack.content[stack.content.length - 1].data.push(initializeString[l]);
                                                                    }
                                                                }
                                                            }
                                                        }

                                                        result = candidate.function(currentContentBuffer.data);
                                                    }
                                                    catch (innerException) {

                                                        throw innerException;
                                                    }
												}
											}
										}


										if (stack.content.length == 0) {
											currentContentBuffer.result += result;
											contentBuffer.push(currentContentBuffer.result);
										}
										else {

											stack.content[stack.content.length - 1].data.push(result);
										}
									}
								}
								else if (line.values[j] == generator.enums.python.symbol.exponent) {
									exponent = true;
								}
								else if (line.values[j] == generator.enums.python.symbol.floorDivision) {
									floor = true;
								}
								else {
									pushToBuffer = true;
								}

								if (pushToBuffer) {
									contentBuffer.push(line.values[j]);
								}
							}
							else if (line.tokens[j] == generator.enums.token.keyword) {

								if (j + 1 != line.tokens.length) {
									if (line.values[j + 1] == generator.enums.symbol.leftParenthesis) {
										stack.count += 1;
										stack.functionName.push(line.values[j]);
										stack.content.push(new StackContent());
									}
								}
							}

							if (stack.count > 0) {

								for (var k = lastContent.length; k < contentBuffer.length; k++) {

									stack.pushData(contentBuffer[k]);
								}

								contentBuffer = lastContent;
							}
						}

						var paramList = [];
						var strBuffer = "";
						var content = "";

						for (var j = 0; j < contentBuffer.length; j++) {

							if (j == 0) {
								strBuffer = contentBuffer[j];
								if (parseDataTypeChange) {
									strBuffer += ".charValue";
								}
							}
							else {

								if (!(contentBuffer[j] == generator.enums.symbol.add || contentBuffer[j] == generator.enums.symbol.equal)) {
									try {

										var arrayList = JSON.parse(contentBuffer[j]);
										if (typeof(arrayList) === generator.enums.c.data.type.object) {

											for (var k = 0; k < arrayList.length; k++) {
												paramList.push(arrayList[k]);
											}
										}
										else {
											paramList.push(contentBuffer[j]);
										}

									}
									catch (exception) {

										paramList.push(contentBuffer[j]);
									}
								}
							}
						}

						line.contentStack.push(dictionary.pages.findWord("sprintf", "C-language").function(strBuffer, paramList));
						//alert(variable.name + " " + variable.type);
					}

                    if (action.type == generator.enums.action.arrayAssignment) {

                        var cloneStack = line.contentStack.slice();
                        cloneStack = cloneStack[0].split(" ");
                        line.contentStack = [];

                        var variableName = "";
                        var variableType = "";
                        var variableContains = [];
                        var actionContain = false;

                        for (var i = 0; i < cloneStack.length; i++) {

                            if (i == 0) {

                                if (variable.type == generator.enums.c.data.type.array.integer) {

                                    variableType = generator.enums.c.data.type.integer;
                                }
                                else if (variable.type == generator.enums.c.data.type.array.float) {

                                    variableType = generator.enums.c.data.type.float;
                                }
                                else if (variable.type == generator.enums.c.data.type.array.bool) {

                                    variableType = generator.enums.c.data.type.bool;
                                }
                                else if (variable.type == generator.enums.c.data.type.array.string) {

                                    variableType = generator.enums.c.data.type.string;
                                }
                                else if (variable.type == generator.enums.c.data.type.array.object) {

                                    variableType = generator.enums.c.data.type.object;
                                }
                            }
                            else if (i == 1) {

                                variableName = cloneStack[i];
                            }


                            if (cloneStack[i] == generator.enums.symbol.closeBracket) {
                                actionContain = false;
                            }

                            if (actionContain) {
                                if (cloneStack[i] != generator.enums.symbol.comma) {
                                    variableContains.push(cloneStack[i]);
                                }
                            }

                            if (cloneStack[i] == generator.enums.symbol.openBracket) {
                                actionContain = true;
                            }
                        }

                        line.contentStack.push(variableType + " " + variableName + " [ " + variableContains.length + " ] = { ");
                        for (var i = 0; i < variableContains.length; i++) {
                            line.contentStack[0] += variableContains[i];
                            if (i + 1 < variableContains.length) {
                                line.contentStack[0] += ", ";
                            }
                        }
                        line.contentStack[0] += " }";
                    }

					if (!legal) {

						if (generator.options.detailedErrors) {
							line.contentStack = [];
							errorHandler.raiseError(new Error(line.lineNumber + 1, line.values.slice(), errorDescription));
						}
					}

					return line;
				},

				processConditionStatement: function (buffer, line, action, legal, definitionStack, currentLanguage, targetLanguage) {

					var contained = false;
					var index = 0;
					var type  = 1;

					line = clone.line(line);
					line.tokens.splice(line.tokens.length - 1, 1);
					line.values.splice(line.values.length - 1, 1);

					for (var i = 0; i < line.values.length; i++) {

						if (line.values[i] == "if") {
							index = i + 1;
							type = 1;
						}
						else if (line.values[i] == "elif") {
							index = i + 1;
							type = 2;
						}
						else if (line.values[i] == "else") {
							index = i + 1;
							type = 3;
						}
					}
					//alert(line.values + " " + type);

					if (line.tokens[index] == generator.enums.token.symbol && line.values[index] == generator.enums.symbol.leftParenthesis) {

						if (line.values[index] == generator.enums.symbol.leftParenthesis && line.values[line.values.length - 1] == generator.enums.symbol.rightParenthesis) {

							contained = true;
						}
					}

					if (type == 3) {
						contained = true;
					}
					line = generator.c.to.python.processBasicStatement(buffer, line, action, legal, definitionStack, currentLanguage, targetLanguage);

					if (contained == false) {

						line.contentStack[0] = generator.enums.symbol.leftParenthesis + " " + line.contentStack[0] + " " + generator.enums.symbol.rightParenthesis;
					}

					if (type == 1) {
						line.contentStack[0] = "if " + line.contentStack[0];
					}
					else if (type == 2) {
						line.contentStack[0] = "else if " + line.contentStack[0];
					}
					else if (type == 3) {
						line.contentStack[0] = "else" + line.contentStack[0];
					}

					return line;
				},

				processLoopStatement: function (buffer, line, action, legal, definitionStack, currentLanguage, targetLanguage) {

					var containerDefined = false;      // determines if the container variable is defined
					var containerExists = false;
					var parenContained = false;
					var loopEndVariable = "";
					var beginLoopVariable = "";
					var contentFlag = false;

					var container = "";
					var variable = "";
					var content = "";

					var index = 0;
					var type  = 0;

					line = clone.line(line);

					if (line.values[line.values.length - 1] == generator.enums.symbol.colon) {
						line.tokens.splice(line.tokens.length - 1, 1);
						line.values.splice(line.values.length - 1, 1);
					}
						

					for (var i = 0; i < line.values.length; i++) {

						if (line.values[i] == "for") {
							index = i + 1;
							type = 1;
						}
						else if (line.values[i] == "while") {
							index = i + 1;
							type = 2;
						}

						if (type == 1) {

							if (line.tokens[i] == generator.enums.token.identifier) {

                                if (containerDefined == false) {
                                    container = line.values[i];
                                    containerDefined = true;
                                    try {

                                        variable = generator.refactor.getVariable(container);
                                        containerExists = true;
                                    }
                                    catch (exception) {
                                    }
                                }
                                else {
                                    try {
                                        generator.refactor.getVariable(line.values[i]);
                                    }
                                    catch (exception) {
                                        throw exception;
                                    }
                                }
							}
							else if (line.values[i - 1] == "in") {

								contentFlag = true;
							}

							if (contentFlag) {
								
								if (line.tokens[i] == generator.enums.token.identifier ||
									line.tokens[i] == generator.enums.token.constant) {
									if (beginLoopVariable === "") {
										beginLoopVariable = line.values[i];
									}
									else {
										loopEndVariable = line.values[i];
									}
								}
								content += line.values[i];
								if (i + 1 < line.values.length) {
									content += " ";
								}
							}
						}
					}


					if (line.tokens[index] == generator.enums.token.symbol && line.values[index] == generator.enums.symbol.leftParenthesis) {

						if (line.values[index] == generator.enums.symbol.leftParenthesis && line.values[line.values.length - 1] == generator.enums.symbol.rightParenthesis) {

							parenContained = true;
						}
					}

					if (type == 1) {

						var initializer = "";
						var cbuffer = "";

						try {

							var keyword = dictionary.pages.findWord(content.split(" ")[0], currentLanguage);
							var equivKeyword = dictionary.search.equivalentWord(targetLanguage, keyword);
							generator.refactor.loopCount += 1;
							var loopVarCount = "s2sc_lpcc" + generator.refactor.loopCount;
							var funcType = "";

							if (keyword.returnType == generator.enums.python.data.structure.list) {

								funcType = equivKeyword.returnType + " *";
							}
							else {

								funcType = equivKeyword.returnType;
							}

							if (containerExists) {
								variable.type = equivKeyword.returnType;
								generator.c.to.python.refactor(variable, buffer);
							}
							else {

								variable = new Variable(container, 0, 0);
								variable.type = equivKeyword.returnType;
								var exist = false;

								if (definitionStack.length > 0) {
									for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

										if (definitionStack[definitionStack.length - 1].variables[j] == variable.name) {
											insideParameter = true;
											exist = true;
											break;
										}
									}
								}

								if (!exist && definitionStack.length > 0) {
									definitionStack[definitionStack.length - 1].variables.push(variable.name);
								}
								generator.refactor.insertVariable(variable);
							}

							equivKeyword.function([]);
							var defined = false;
							try {
                                generator.refactor.getVariable(container + "Loop");
                                defined = true;
							}
							catch (exception) {

							}

							if (defined) {
                                line.contentStack.push(container + "Loop = " + content.replace(keyword.name, equivKeyword.name) + ";");
							}
							else {

                                line.contentStack.push(funcType + " " + container + "Loop = " + content.replace(keyword.name, equivKeyword.name) + ";");
                                var containerVariable = clone.variable(variable);
                                containerVariable.name = container + "Loop";
                                containerVariable.type = funcType;
                                if (definitionStack.length > 1) {

                                    for (var j = definitionStack.length - 1; j >= 0; j--) {
                                        if (definitionStack[j].definitionType == generator.enums.definition.function) {
                                            definitionStack[j].variables.push(containerVariable.name);
                                        }
                                    }
                                }
                                generator.refactor.insertVariable(containerVariable);
							}

							//cbuffer = "for (" + equivKeyword.returnType + " " + loopVarCount + " = 0, " + container + " = " + container + "Loop" + "[" + loopVarCount + "]; " + container + "Loop" + "[" + loopVarCount + "]; " + loopVarCount + "++" + ", " + container + " = " + container + "Loop" + "[" + loopVarCount + "])";
							cbuffer = "for (" + equivKeyword.returnType + " " + loopVarCount + " = 0, " + container + " = " + container + "Loop" + "[" + loopVarCount + "]; " + loopVarCount + " < " + loopEndVariable + " - " + beginLoopVariable + "; " + loopVarCount + "++" + ", " + container + " = " + container + "Loop" + "[" + loopVarCount + "])";
						}
						catch (exception) {

							throw exception;
						}

						line.contentStack.push(cbuffer);
					}
					else if (type == 2) {

						line = generator.c.to.python.processBasicStatement(buffer, line, action, legal, definitionStack, currentLanguage, targetLanguage);
						if (!parenContained) {
                            line.contentStack[0] = generator.enums.symbol.leftParenthesis + " " + line.contentStack[0] + " " + generator.enums.symbol.rightParenthesis;
						}
						line.contentStack[0] = "while " + line.contentStack[0];
					}

                    line.actionStack.push(action);
					return line;
				},

				processUserDefinedFunction: function (buffer, func, valueParameters) {

					var argumentNameList = [];
					var tmpRefactorVariables = generator.refactor.variableList.slice();
                    var returnType = "void";
                    var parameterString = "";
                    var tabSpace = "";
                    var fcontent = [];
                    var content = "";
					var result = "";
					generator.refactor.clear();

					var lbuffer = [];
                    for (var i = 0; i < func.arguments.length; i++) {

						lbuffer.push(func.arguments[i] + " = ");
                    }

					var lindex = 0;
                    for (var i = 0; i < valueParameters.length; i++) {

						if (valueParameters[i] != generator.enums.symbol.comma) {

                            var isambiguous = false;
                            var parameterValue = valueParameters[i];
                            if (parameterValue.indexOf("Value") != -1) {
                                if (parameterValue.indexOf("intValue") != 1) {
                                    isambiguous = true;
                                }
                                else if (parameterValue.indexOf("charValue") != 1) {
                                    isambiguous = true;
                                }
                                else if (parameterValue.indexOf("floatValue") != 1) {
                                    isambiguous = true;
                                }
                                else if (parameterValue.indexOf("doubleValue") != 1) {
                                    isambiguous = true;
                                }
                            }

                            if (isambiguous) {
                                var sIndex = -1;
                                var eIndex = -1;
                                for (var j = 0; j < parameterValue.length; j++) {
                                    if (parameterValue[j] == "*"){
                                        sIndex = j;
                                    }

                                    if (parameterValue[j] == "."){
                                        eIndex = j;
                                        break;
                                    }
                                }
                                parameterValue = (parameterValue.substring(sIndex + 1, eIndex));
                            }

							lbuffer[lindex] += parameterValue;
							lindex += 1;
						}
                    }

                    // This one re-evaluates the variables passed through function
                    // parameters

                    var parameterVariables = [];

					for (var i = 0; i < lbuffer.length; i++) {

						var paramToken = tokenizer.python.tokenize(lbuffer[i])[0];
						var paramMap = tokenizer.detokenize(paramToken);
						var paramValues = paramMap.slice();
						var paramID = paramMap.slice();

						generator.refactor.clear();


						for (var j = 0; j < paramValues.length; j++) {

							var currentSelector = paramValues[j].replace(/\d+/g, '');
							var currentIndex 	= paramValues[j].replace(/[^0-9.]/g, '');

							paramMap[j] = currentSelector;
							if (currentSelector == generator.enums.token.keyword) {

								paramValues[j] = tokenizer.token.keyword[currentIndex - 1].value;
							}
							else if (currentSelector == generator.enums.token.identifier) {

								paramValues[j] = tokenizer.token.identifier[currentIndex - 1].value;
							}
							else if (currentSelector == generator.enums.token.symbol) {

								paramValues[j] = tokenizer.token.symbol[currentIndex - 1].value;
							}
							else if (currentSelector == generator.enums.token.constant) {

								paramValues[j] = tokenizer.token.constant[currentIndex - 1].value;
							}
							else if (currentSelector == generator.enums.token.reserveWord) {

								paramValues[j] = tokenizer.token.reserveWord[currentIndex - 1].value;
							}
							else if (currentSelector == generator.enums.token.stringConstant) {

								paramValues[j] = "\"" + tokenizer.token.string[currentIndex - 1].value + "\"";
							}
							else if (currentSelector == generator.enums.token.tab) {
								paramValues[j] = "\t";
							}
						}



						if (paramMap[2] == generator.enums.token.identifier) {

                            for (var j = 0; j < tmpRefactorVariables.length; j++) {

                                if (paramValues[2] == tmpRefactorVariables[j].name) {
                                    generator.refactor.insertVariable(tmpRefactorVariables[j]);
                                }
                            }
						}

						lbuffer[i] = new Line(-1, paramMap, paramValues, paramID);
						lbuffer[i].actionStack.push(new Action(parser.parse(paramToken, "Python-language").symbol));
						var tmpLine = generator.c.to.python.processDeclarativeStatement(new Array(), lbuffer[i], lbuffer[i].actionStack[0], true, new Array(), "Python-language", "C-language");

                        try {

                            parameterVariables.push(generator.refactor.getVariable(paramValues[0]));
                        }
                        catch (exception) {
                            //console.log(tmpLine);
                        }

					}


					generator.refactor.variableList = parameterVariables.slice();


					for (var j = 0; j <= func.indention; j++) {

						tabSpace += "\t";
					}

					var argumentList = [];

					var tabCountList = [];
					var tabExtraSpace= "";

					for (var i = 0; i < func.contains.length; i++) {

						if (func.contains[i].actionStack.length < 1) {
							continue;
						}

                        var action = func.contains[i].actionStack[0];

                        if (action.type == generator.enums.action.declaration       ||
							action.type == generator.enums.action.stringDeclaration ||
							action.type == generator.enums.action.booleanDeclaration||
							action.type == generator.enums.action.arrayAssignment) {

							fcontent.push(generator.c.to.python.processDeclarativeStatement(new Array(), func.contains[i], func.contains[i].actionStack[0], true, new Array(), "Python-language", "C-language"));
						}
						else if (action.type == generator.enums.action.basic.constant  ||
							action.type == generator.enums.action.basic.stringConstant ||
							action.type == generator.enums.action.basic.result         ||
							action.type == generator.enums.action.basic.id             ||
							action.type == generator.enums.action.basic.increment      ||
							action.type == generator.enums.action.compoundAssignment   ||
							action.type == generator.enums.action.basic.boolean        ||
							action.type == generator.enums.action.return.void          ||
							action.type == generator.enums.action.return.constant      ||
							action.type == generator.enums.action.return.string        ||
							action.type == generator.enums.token.comment ||
							action.type == undefined) {

                            var tmpL = generator.c.to.python.processBasicStatement(new Array(), func.contains[i], func.contains[i].actionStack[0], true, new Array(), "Python-language", "C-language");
                            tmpL.comment = true;

							if (tmpL.contentStack.length == 0) {
                                tmpL = func.contains[i];
							}
							fcontent.push(tmpL);
						}
						else if (action.type == generator.enums.action.conditionStatement) {

							fcontent.push(func.contains[i]);
						}
						else if (action.type == generator.enums.action.conditionStatementClosure) {

							fcontent.push(func.contains[i]);
						}
						else if (action.type == generator.enums.action.loopStatement) {

							var cLine = generator.c.to.python.processLoopStatement(new Array(), func.contains[i], func.contains[i].actionStack[0], true, new Array(), "Python-language", "C-language");
							cLine.contentStack[1] += " {";
                            fcontent.push(cLine);
						}


					}

					for (var i = 0; i < fcontent.length; i++) {


						for (var j = 0; j < fcontent[i].contentStack.length; j++) {

							var symbol = "";
							var insert = true;

							for (var k = 0; k < fcontent[i].actionStack.length; k++) {
                                symbol = fcontent[i].actionStack[k].type;
							}


							if (symbol == generator.enums.c.action.return.undefined || symbol == generator.enums.c.action.return.constant || symbol == generator.enums.c.action.return.string) {

								returnType = isEquation(fcontent[i].contentStack[j].replace("return ", ""));
							}

							if (fcontent[i].clauseStatement) {

								var tabCounter = 0;
								content += tabSpace + fcontent[i].contentStack[j] + "\n";

								for (var k = 0; k < fcontent[i].contentStack[j].length; k++) {

									if (fcontent[i].contentStack[j][k] == '\t') {
										tabCounter = tabCounter + 1;
									}
								}

								if (tabCountList.length > 0) {

									if (tabCountList[tabCountList.length - 1] == tabCounter) {
										insert = false;
										tabCountList.pop();
										tabExtraSpace = "";
									}
								}


								if (insert) {
									tabCountList.push(tabCounter);
									for (var k = 0; k < tabCounter; k++) {
										tabExtraSpace += "\t";
									}
								}

							}
							else {

								tabExtraSpace = "";

								var tabLength = 0;
								try {

									tabLength = tabCountList[tabCountList.length - 1] + 1;
								}
								catch (exception) {

									tabLength = 0;
								}

								for (var k = 0; k < tabLength; k++) {
									tabExtraSpace += "\t";
								}

								if (fcontent[i].contentStack[j][fcontent[i].contentStack[j].length - 1] != "{" &&
									fcontent[i].contentStack[j][fcontent[i].contentStack[j].length - 1] != ";") 
									content += tabSpace + tabExtraSpace + fcontent[i].contentStack[j] + ";\n";
								else {
									content += tabSpace + tabExtraSpace + fcontent[i].contentStack[j] + "\n";
									if (fcontent[i].contentStack[j][fcontent[i].contentStack[j].length - 1] != ";") {

										tabCountList.push(1);
									}
								}
							}

						}
					}

					if (returnType == generator.enums.c.data.type.string) {
						returnType = generator.enums.c.symbol.string;
                    }

                    for (var i = 0; i < func.arguments.length; i++) {

						var variable = "";
						var type = "";

						try {
							variable = generator.refactor.getVariable(func.arguments[i]);
						}
						catch (searchException) {

							// If ever the searchException is thrown, it means that
							// that line inside the function is using a parameter variable
							// it will then search on the refactor list then fetches it back to
							// the argument list.

							argumentList = generator.refactor.variableList.slice();
							generator.refactor.variableList = tmpRefactorVariables.slice();
							variable = generator.refactor.getVariable(func.arguments[i]);
							argumentList.push(variable);
							generator.refactor.variableList = argumentList.slice();
						}

						type = variable.type;

						if (type == generator.enums.c.data.type.string) {
							type = generator.enums.c.symbol.string;
						}

						if (variable.ambiguous) {
                            type = "ambiguous";
						}

						parameterString += type + " " + variable.name;
						if (i + 1 != func.arguments.length) {

							parameterString += ", ";
						}
					}

					generator.functions.insert(func.name, content, returnType, parameterString);

					dictionary.pages.addWord(new Word(
						func.name, function(value) {

							var parameterString = "";
							var parameterLineBuffer = "";
							for (var i = 0; i < value.length; i++) {

								if (value[i] != generator.enums.symbol.comma) {

									parameterLineBuffer += value[i];
									var isambiguous = false;

                                    if (value[i].indexOf("Value") != -1) {
                                        if (value[i].indexOf("intValue") != 1) {
                                            isambiguous = true;
                                        }
                                        else if (value[i].indexOf("charValue") != 1) {
                                            isambiguous = true;
                                        }
                                        else if (value[i].indexOf("floatValue") != 1) {
                                            isambiguous = true;
                                        }
                                        else if (value[i].indexOf("doubleValue") != 1) {
                                            isambiguous = true;
                                        }
                                    }

                                    if (isambiguous) {
                                        parameterString += value[i];
                                    }
								}

								if (value[i] == generator.enums.symbol.comma || i + 1 == value.length) {

									var paramToken = tokenizer.python.tokenize(parameterLineBuffer)[0];
									var paramMap = tokenizer.detokenize(paramToken);
									var paramValues = paramMap.slice();
									var paramID = paramMap.slice();

									for (var j = 0; j < paramValues.length; j++) {

										var currentSelector = paramValues[j].replace(/\d+/g, '');
										var currentIndex 	= paramValues[j].replace(/[^0-9.]/g, '');

										paramMap[j] = currentSelector;
										if (currentSelector == generator.enums.token.keyword) {

											paramValues[j] = tokenizer.token.keyword[currentIndex - 1].value;
										}
										else if (currentSelector == generator.enums.token.identifier) {

											paramValues[j] = tokenizer.token.identifier[currentIndex - 1].value;
										}
										else if (currentSelector == generator.enums.token.symbol) {

											paramValues[j] = tokenizer.token.symbol[currentIndex - 1].value;
										}
										else if (currentSelector == generator.enums.token.constant) {

											paramValues[j] = tokenizer.token.constant[currentIndex - 1].value;
										}
										else if (currentSelector == generator.enums.token.reserveWord) {

											paramValues[j] = tokenizer.token.reserveWord[currentIndex - 1].value;
										}
										else if (currentSelector == generator.enums.token.stringConstant) {

											paramValues[j] = "\""
											+ tokenizer.token.string[currentIndex - 1].value + "\"";
										}
										else if (currentSelector == generator.enums.token.tab) {
											paramValues[j] = "\t";
										}

									}

									var isambiguous = false;

                                    if (value[i].indexOf("Value") != -1) {
                                        if (value[i].indexOf("intValue") != 1) {
                                            isambiguous = true;
                                        }
                                        else if (value[i].indexOf("charValue") != 1) {
                                            isambiguous = true;
                                        }
                                        else if (value[i].indexOf("floatValue") != 1) {
                                            isambiguous = true;
                                        }
                                        else if (value[i].indexOf("doubleValue") != 1) {
                                            isambiguous = true;
                                        }
                                    }

                                    var resultLine = generator.c.to.python.processBasicStatement(new Array(), new Line(-1, paramMap, paramValues, paramID), new Action(parser.parse(paramToken, "Python-language").symbol), true, new Array(), "C-language", "Python-language");
                                    if (isambiguous) {

                                        parameterString += value[i];
                                    }
                                    else {

                                        if (resultLine.contentStack.length > 0)
                                            parameterString += resultLine.contentStack[0];
                                    }

									if (value[i] == generator.enums.symbol.comma) {
										parameterString += ", ";
									}

									parameterLineBuffer = "";
								}

								if (i + 1 != value.length && value[i + 1] != generator.enums.symbol.comma) {

									parameterLineBuffer += " ";
								}
							}
							return this.name + "(" + parameterString + ")";
						}
					, new Array("user-defined", func.name, "C-language"), returnType));
					
					func._varList = generator.refactor.variableList;
					result = dictionary.pages.findWord(func.name, "C-language");
					generator.refactor.variableList = tmpRefactorVariables.slice();
					return result;
				},
			},
		},
	},

	// Generates code from a current language to a targetted language
	generateCode: function (currentLanguage, targetLanguage, parseData) {

		var string = "";
		var bodyText = "";
		var result = "";
		var buffer = new Array();
		var hasReturnType = false;

		generator.headers.clear();
		generator.defines.clear();
		generator.refactor.clear();
		generator.unions.clear();
		generator.structures.clear();
		generator.functions.clear();

        // Container of loop and functions
        // as it is scanned by the generator
        // also keeps in track of the temporary
        // variables declared inside them.

		var definitionStack  = [];
		generator.refactor.functionList = [];
		generator.refactor.loopCount = 0;
		generator.refactor.paramMDCount = 0;
		generator.refactor.typeChangeCount = 0;

		for (var i = 0; i < parseData.symbol.length; i++) {

            var tokens = [], tokensAheadByOne = [];
            var values = [], valuesAheadByOne = [];
            var tokenIDs = [];
            var tabCount = 0, tabCountAheadByOne = -1;

			if (i + 1 != parseData.symbol.length) {

				tokensAheadByOne = tokenizer.detokenize(parseData.map[i + 1]);
				valuesAheadByOne = tokensAheadByOne.slice();
				tabCountAheadByOne = 0;

				for (var j = 0; j < valuesAheadByOne.length; j++) {

					var currentSelector = valuesAheadByOne[j].replace(/\d+/g, '');
					var currentIndex 	= valuesAheadByOne[j].replace(/[^0-9.]/g, '');

					tokens[j] = currentSelector;
					if (currentSelector == generator.enums.token.keyword) {

						valuesAheadByOne[j] = tokenizer.token.keyword[currentIndex - 1].value;
					}
					else if (currentSelector == generator.enums.token.identifier) {

						valuesAheadByOne[j] = tokenizer.token.identifier[currentIndex - 1].value;
					}
					else if (currentSelector == generator.enums.token.symbol) {

						valuesAheadByOne[j] = tokenizer.token.symbol[currentIndex - 1].value;
					}
					else if (currentSelector == generator.enums.token.constant) {

						valuesAheadByOne[j] = tokenizer.token.constant[currentIndex - 1].value;
					}
					else if (currentSelector == generator.enums.token.reserveWord) {

						valuesAheadByOne[j] = tokenizer.token.reserveWord[currentIndex - 1].value;
					}
					else if (currentSelector == generator.enums.token.stringConstant) {

						valuesAheadByOne[j] = "\""
						+ tokenizer.token.string[currentIndex - 1].value + "\"";
					}
					else if (currentSelector == generator.enums.token.tab) {
						valuesAheadByOne[j] = "\t";
						tabCountAheadByOne += 1;
					}
				}
            }

			tokens = tokenizer.detokenize(parseData.map[i]);
			values = tokens.slice();
			tokenIDs = tokens.slice();


            for (var j = 0; j < values.length; j++) {

                var currentSelector = values[j].replace(/\d+/g, '');
                var currentIndex 	= values[j].replace(/[^0-9.]/g, '');

                tokens[j] = currentSelector;
                if (currentSelector == generator.enums.token.keyword) {

                    values[j] = tokenizer.token.keyword[currentIndex - 1].value;
                }
                else if (currentSelector == generator.enums.token.identifier) {

                    values[j] = tokenizer.token.identifier[currentIndex - 1].value;
                }
                else if (currentSelector == generator.enums.token.symbol) {

                    values[j] = tokenizer.token.symbol[currentIndex - 1].value;
                }
                else if (currentSelector == generator.enums.token.constant) {

                    values[j] = tokenizer.token.constant[currentIndex - 1].value;
                }
                else if (currentSelector == generator.enums.token.reserveWord) {

                    values[j] = tokenizer.token.reserveWord[currentIndex - 1].value;
                }
                else if (currentSelector == generator.enums.token.stringConstant) {

                    values[j] = "\""
                    + tokenizer.token.string[currentIndex - 1].value + "\"";
                }
                else if (currentSelector == generator.enums.token.tab) {
                	values[j] = "\t";
                	tabCount += 1;
                }
            }

            var line = new Line(i, tokens.slice(), values, tokenIDs);

			var action = new Action(parseData.symbol[i]);
            var legal = true;

            // Grouped each type of statements into their appropriate actions,
            // this approach will greatly increase the # of LOCs but I think
            // this is the best approach because it consolidates possible bugs
            if (action.type == generator.enums.action.declaration ||
                action.type == generator.enums.action.stringDeclaration ||
                action.type == generator.enums.action.booleanDeclaration ||
                action.type == generator.enums.action.arrayAssignment) {

				// If the line is defined as a header of a function, it will not be processed but will be recorded on
				// the definition stack
				if (definitionStack.length > 0 && definitionStack[definitionStack.length - 1].definitionType == generator.enums.definition.function) {

					line.actionStack.push(action);
				}
				else {

					line = generator.c.to.python.processDeclarativeStatement(buffer, line, action, legal, definitionStack, currentLanguage, targetLanguage);
				}
            }
			else if (action.type == generator.enums.action.basic.constant ||
					 action.type == generator.enums.action.basic.stringConstant ||
					 action.type == generator.enums.action.basic.result ||
					 action.type == generator.enums.action.basic.id ||
					 action.type == generator.enums.action.basic.increment ||
					 action.type == generator.enums.action.compoundAssignment ||
					 action.type == generator.enums.action.basic.boolean ||
					 action.type == generator.enums.action.return.void ||
					 action.type == generator.enums.action.return.constant ||
					 action.type == generator.enums.action.return.string ||
					 action.type == generator.enums.token.comment ||
					 action.type == undefined) {

				if (definitionStack.length > 0 && definitionStack[definitionStack.length - 1].definitionType == generator.enums.definition.function) {

					line.actionStack.push(action);
				}
				else {

					line = generator.c.to.python.processBasicStatement(buffer, line, action, legal, definitionStack, currentLanguage, targetLanguage);
				}

				if (action.type == undefined) {
                    line.comment = true;
                }
			}
			else if (action.type == generator.enums.action.functionDefinition) {

                var funcName = "";
                var funcArgs = [];

                for (var j = 0; j < line.tokens.length; j++) {

                    if (line.tokens[j] == generator.enums.token.identifier) {

                        if (funcName == "") {
                            funcName = line.values[j];
                        }
                        else {
                            funcArgs.push(line.values[j]);
                            try {

								var variable = new Variable(line.values[j], 0, 0, false, true);
								generator.refactor.insertVariable(variable);
                            }
                            catch (exception) {

								throw exception;
                            }
                        }
                    }
                    else if (line.tokens[j] == generator.enums.token.keyword) {

						if (funcName == "") {
                            funcName = line.values[j];
                        }
                    }
                }

				if (funcName != "main") {

					definitionStack.push(new tmpDefinitionState(funcName, funcArgs, tabCount, new Array(), generator.enums.definition.function, funcArgs.slice()));
				}
                continue;
			}
			else if (action.type == generator.enums.action.conditionStatement) {

				line = generator.c.to.python.processConditionStatement(buffer, line, action, legal, definitionStack, currentLanguage, targetLanguage);
				definitionStack.push(new tmpDefinitionState("", new Array(), tabCount, new Array(), generator.enums.definition.condition, new Array()));
			}
			else if (action.type == generator.enums.action.loopStatement) {

				definitionStack.push(new tmpDefinitionState("", new Array(), tabCount, new Array(), generator.enums.definition.loop, new Array()));
				line = generator.c.to.python.processLoopStatement(buffer, line, action, legal, definitionStack, currentLanguage, targetLanguage);

			}
			else if (action.type == generator.enums.action.import) {

                // To do: Import translation here
                errorHandler.raiseError(new Error(i + 1, values.slice(), "Import statements not currently supported"));
			}
			else if (action.type == generator.enums.error.parse) {

				var parseError = "Syntax Error";
				if (tokens[0] == generator.enums.token.keyword) {
					parseError += ": Invalid use of function parameter";
				}
				else if (tokens[0] == generator.enums.token.stringConstant ||
						 tokens[0] == generator.enums.token.constant) {
					parseError += ": Numeric and Strings cannot be combined directly.";
				}
				else if (tokens[0] == generator.enums.token.reserveWord && values[0] == "def") {

					var colonFound = false;
					for (var x = 0; x < values.length; x++) {
						if (values[x] == ":") {
							colonFound = true;
						}
					}

					if (colonFound) {
						parseError += ": Illegal use of function definition";
					}
					else {
						parseError += ": Missing ':' in function definition";
					}
				}
				errorHandler.raiseError(new Error(i + 1, values.slice(), parseError));
			}

            var pushToBuffer = true;

			// This line here tells whether or not a line of code is inside a function
			// or not.

            if (definitionStack.length > 0) {

                var lastDefinition = definitionStack[definitionStack.length - 1];
                lastDefinition.contains.push(line);

                if (lastDefinition.indention == tabCountAheadByOne) {

                    //generator.functions.insert(lastDefinition.name, content, returnType, parameterString);
                    if (lastDefinition.definitionType == generator.enums.definition.function) {

						tokenizer.python.token.add.keyword(lastDefinition.name);
						dictionary.pages.addWord(new Word(
							lastDefinition.name, function(value) {
								return this.name + "(" + value.join(" ") + ")";
							}
						, new Array(lastDefinition.name, "user-defined", "Python-language"), generator.enums.python.data.type.integer));

						generator.refactor.functionList.push(lastDefinition);
						generator.reparse = true;
                    }
                    else if (lastDefinition.definitionType == generator.enums.definition.condition) {

						// Add condition statement generation here
						for (var j = 0; j < lastDefinition.contains.length; j++) {

							var tmpLine = lastDefinition.contains[j];
							if (j == 0) {

								tmpLine.clauseStatement = true;
								tmpLine.contentStack[0] += " " + generator.enums.symbol.openCurlBrace;
							}
							else {

								for (var k = 0; k < lastDefinition.indention; k++) {

									tmpLine.contentStack[0] = "\t" + tmpLine.contentStack[0];
								}
							}

							if (definitionStack.length - 1 > 0) {

								definitionStack[definitionStack.length - 2].contains.push(tmpLine);
							}
							else {
								buffer.push(tmpLine);
							}

						}

						// This is for inserting the closing bracket for the condition statement.
						// If it sees that there is still content inside the definitionStack,
						// the line buffer is instead pushed to the top of the stack, else it
						// the line is pushed directly to the buffer.

						var tmpCopyLine = clone.line(tmpLine);
						tmpCopyLine.actionStack =  [];
						tmpCopyLine.contentStack = [];
						tmpCopyLine.actionStack.push(new Action(generator.enums.action.conditionStatementClosure));
						tmpCopyLine.contentStack.push(generator.enums.symbol.closeCurlBrace);
						tmpCopyLine.values = [];
						tmpCopyLine.tokens = [];
						tmpCopyLine.length = 0;
						tmpCopyLine.id = [];
						tmpCopyLine.clauseStatement = true;

						if (definitionStack.length - 1 > 0) {

							definitionStack[definitionStack.length - 2].contains.push(tmpCopyLine);
						}
						else {
							buffer.push(tmpCopyLine);
						}

						for (var j = 0; j < lastDefinition.variables.length; j++) {
                            generator.refactor.removeVariable(lastDefinition.variables[j]);
						}
                    }
					else if (lastDefinition.definitionType == generator.enums.definition.loop) {

						generator.refactor.loopCount -= 1;
						for (var j = 0; j < lastDefinition.contains.length; j++) {

							var tmpLine = lastDefinition.contains[j];
							var type = tmpLine.contentStack.length > 1 ? 1 : 2;

							if (j == 0) {

								tmpLine.clauseStatement = true;

								if (type == 1) {
									tmpLine.contentStack[1] += " " + generator.enums.symbol.openCurlBrace;
								}
								else {
									tmpLine.contentStack[0] += " " + generator.enums.symbol.openCurlBrace;
								}

							}
							else {

								if (typeof(tmpLine.arranged) === "undefined") {
									tmpLine.arranged = false;
								}

								if (!tmpLine.arranged) {

									for (var k = 0; k < lastDefinition.indention; k++) {

										tmpLine.contentStack[0] = "\t" + tmpLine.contentStack[0];
									}

									tmpLine.arranged = true;
								}
							}

							if (definitionStack.length - 1 > 0) {

								definitionStack[definitionStack.length - 2].contains.push(tmpLine);
							}
							else {
								buffer.push(tmpLine);
							}
						}

						var tmpCopyLine = clone.line(tmpLine);
						tmpCopyLine.actionStack =  [];
						tmpCopyLine.contentStack = [];
						tmpCopyLine.actionStack.push(new Action(generator.enums.action.conditionStatementClosure));
						tmpCopyLine.contentStack.push(generator.enums.symbol.closeCurlBrace);
						tmpCopyLine.values = [];
						tmpCopyLine.tokens = [];
						tmpCopyLine.length = 0;
						tmpCopyLine.id = [];
						tmpCopyLine.clauseEnd = true;
						tmpCopyLine.clauseStatement = true;


						if (definitionStack.length - 1 > 0) {

							definitionStack[definitionStack.length - 2].contains.push(tmpCopyLine);
						}
						else {
							buffer.push(tmpCopyLine);
						}
						for (var j = 0; j < lastDefinition.variables.length; j++) {

							generator.refactor.removeVariable(lastDefinition.variables[j]);
						}
					}

                    definitionStack.pop();
                }
                else if (lastDefinition.indention > tabCountAheadByOne || tabCountAheadByOne == -1) {

					while (definitionStack.length > 0) {

						if (lastDefinition.indention == tabCountAheadByOne) {
							break;
						}

						var lastDefinition = definitionStack[definitionStack.length - 1];
						if (lastDefinition.definitionType == generator.enums.definition.function) {

							tokenizer.python.token.add.keyword(lastDefinition.name);
							dictionary.pages.addWord(new Word(
								lastDefinition.name, function(value) {
									return this.name + "(" + value.join(" ") + ")";
								}
							, new Array(lastDefinition.name, "user-defined", "Python-language"), generator.enums.python.data.type.integer));

							generator.refactor.functionList.push(lastDefinition);
							generator.reparse = true;
							for (var j = 0; j < lastDefinition.variables.length; j++) {

								generator.refactor.removeVariable(lastDefinition.variables[j]);
							}
						}
						else if (lastDefinition.definitionType == generator.enums.definition.condition) {

							// Add condition statement generation here

							for (var j = 0; j < lastDefinition.contains.length; j++) {

								var tmpLine = lastDefinition.contains[j];
								if (j == 0) {

									tmpLine.clauseStatement = true;
									tmpLine.contentStack[0] += " " + generator.enums.symbol.openCurlBrace;
								}
								else {

									//alert(typeof(tmpLine.arranged) === "undefined");
									if (typeof(tmpLine.arranged) === "undefined") {
										tmpLine.arranged = false;
									}

									if (!tmpLine.arranged) {

										//alert(lastDefinition.indention + "=>" + tmpLine.contentStack[0]);
										for (var k = 0; k < lastDefinition.indention; k++) {
											//////////////////////////////////////////////////////
											//  Need to do something about that tabbing spaces  //
											//  that happens when there are nested statements   //
											//////////////////////////////////////////////////////
											tmpLine.contentStack[0] = "\t" + tmpLine.contentStack[0];
										}
										//alert(lastDefinition.indention + "=>" + tmpLine.contentStack[0]);
										tmpLine.arranged = true;
									}
								}

								if (definitionStack.length - 1 > 0) {

									definitionStack[definitionStack.length - 2].contains.push(tmpLine);
								}
								else {
									buffer.push(tmpLine);
								}

							}

							var tmpCopyLine = clone.line(tmpLine);
							tmpCopyLine.actionStack =  [];
							tmpCopyLine.contentStack = [];
							tmpCopyLine.actionStack.push(new Action(generator.enums.action.conditionStatementClosure));
							tmpCopyLine.contentStack.push(generator.enums.symbol.closeCurlBrace);
							tmpCopyLine.values = [];
							tmpCopyLine.tokens = [];
							tmpCopyLine.length = 0;
							tmpCopyLine.id = [];
							tmpCopyLine.clauseEnd = true;
							tmpCopyLine.clauseStatement = true;


							if (definitionStack.length - 1 > 0) {

								definitionStack[definitionStack.length - 2].contains.push(tmpCopyLine);
							}
							else {
								buffer.push(tmpCopyLine);
							}

							for (var j = 0; j < lastDefinition.variables.length; j++) {

								generator.refactor.removeVariable(lastDefinition.variables[j]);
							}
						}
						else if (lastDefinition.definitionType == generator.enums.definition.loop) {

							generator.refactor.loopCount -= 1;
							for (var j = 0; j < lastDefinition.contains.length; j++) {

								var tmpLine = lastDefinition.contains[j];
								var type = tmpLine.contentStack.length > 1 ? 1 : 2;

								if (j == 0) {

									tmpLine.clauseStatement = true;

									if (type == 1) {
										tmpLine.contentStack[1] += " " + generator.enums.symbol.openCurlBrace;
									}
									else {
										tmpLine.contentStack[0] += " " + generator.enums.symbol.openCurlBrace;
									}

								}
								else {

									if (typeof(tmpLine.arranged) === "undefined") {
										tmpLine.arranged = false;
									}

									if (!tmpLine.arranged) {

										for (var k = 0; k < lastDefinition.indention; k++) {

											tmpLine.contentStack[0] = "\t" + tmpLine.contentStack[0];
										}

										tmpLine.arranged = true;
									}
								}

								if (definitionStack.length - 1 > 0) {

									definitionStack[definitionStack.length - 2].contains.push(tmpLine);
								}
								else {
									buffer.push(tmpLine);
								}
							}

							var tmpCopyLine = clone.line(tmpLine);
							tmpCopyLine.actionStack =  [];
							tmpCopyLine.contentStack = [];
							tmpCopyLine.actionStack.push(new Action(generator.enums.action.conditionStatementClosure));
							tmpCopyLine.contentStack.push(generator.enums.symbol.closeCurlBrace);
							tmpCopyLine.values = [];
							tmpCopyLine.tokens = [];
							tmpCopyLine.length = 0;
							tmpCopyLine.id = [];
							tmpCopyLine.clauseEnd = true;
							tmpCopyLine.clauseStatement = true;


							if (definitionStack.length - 1 > 0) {

								definitionStack[definitionStack.length - 2].contains.push(tmpCopyLine);
							}
							else {
								buffer.push(tmpCopyLine);
							}

							for (var j = 0; j < lastDefinition.variables.length; j++) {
								generator.refactor.removeVariable(lastDefinition.variables[j]);
							}
						}

						definitionStack.pop();
					}
                }

                pushToBuffer = false;
            }

            if (pushToBuffer) {

                buffer.push(line);
            }
		}

		for (var i = 0; i < generator.headers.list.length; i++) {
			generator.variables.headerString += "#include <" + generator.headers.list[i] + ">\n";
		}

		for (var i = 0; i < generator.defines.list.length; i++) {
			generator.variables.defineString += "#define " + generator.defines.list[i].name + " " + generator.defines.list[i].content  +"\n";
		}

		for (var i = 0; i < generator.structures.list.length; i++) {
			generator.variables.struct += "\ntypedef struct {\n" + generator.structure.list[i].content + "} " + generator.structure.list[i].name + ";\n\n";
		}

		for (var i = 0; i < generator.unions.list.length; i++) {
			generator.variables.union += "\ntypedef union {\n" + generator.unions.list[i].content + "} " + generator.unions.list[i].name + ";\n\n";
		}

		for (var i = 0; i < generator.functions.list.length; i++) {
			generator.variables.functions += generator.functions.list[i].type + " " + generator.functions.list[i].name + " (" + generator.functions.list[i].param + ") {\n" + generator.functions.list[i].content + "}\n\n";
		}

		var tabExtraSpace = "";
		var tabCount = 0;

		for (var i = 0; i < buffer.length; i++) {

			var addTab = false;
			for (var j = 0; j < buffer[i].contentStack.length; j++) {

				if (!buffer[i].clauseStatement) {
                    if (!buffer[i].comment) {
                        bodyText += "\t" + tabExtraSpace + buffer[i].contentStack[j] + ";\n";
                    }
					else {
                        bodyText += "\t" + tabExtraSpace + buffer[i].contentStack[j] + "\n";
					}
				}
				else {

					if (buffer[i].contentStack[j] == generator.enums.symbol.closeCurlBrace) {
						buffer[i].clauseEnd = true;
					}

					if (typeof(buffer[i].clauseEnd) !== "undefined") {
						tabCount -= 1;
						if (tabCount <= 0) {
							tabExtraSpace = "";
						}
					}

					bodyText += "\t" + tabExtraSpace + buffer[i].contentStack[j] + "\n";
				}
			}

			if (buffer[i].clauseStatement && typeof(buffer[i].clauseEnd) === "undefined") {
				tabExtraSpace = "\t";
				tabCount += 1;
			}
		}

		if (errorHandler.stack.length > 0) {
			if (generator.reparse && generator.reparseCount > 0 || !generator.reparse) 
				errorHandler.throwException();
		}
		else {

			result = generator.variables.comment + generator.variables.headerString +
			"\n" + generator.variables.defineString + "\n" + generator.variables.struct + generator.variables.union +
			generator.variables.functions + generator.variables.bodyBegin + bodyText +
			generator.variables.bodyEnd;

			return result;
		}

	},

	// Holds the options to be used during code generation
	options: {

		// Comments out the offending statement that caused the error
		detailedErrors: true,

		// Work only when code is generate to C, will use double instead of float during data type.
		useDoubleInsteadOfFloat: true,
	},

	reparse: false,
	reparseCount: 0,
}
