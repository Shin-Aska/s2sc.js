/**
 *
 * @source: generator.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in this page.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in this page.
 *
 */

// Variable object is the representation of a variable
// as it is parsed and generated by s2sc
function Variable (Vname, Vtype, Vline, Vambigious, Vtemp) {


	if (typeof(Vambigious) === "undefined") {
		Vambigious = false;
	}

	if (typeof(Vtemp) === "undefined") {
		Vtemp = false;
	}

	this.name = Vname;
	this.type = Vtype;
	this.lineDeclared = Vline;
	this.ambigious = Vambigious;
	this.temporary = Vtemp;
}

// This holds information about what type of statement it holds
// and the state of the variables during that line.
function Action (Atype) {

	this.type = Atype;
	this.state = [];

	this.pushVariableState = function(variable) {

		var found = false;

		for (var i = 0; i < this.state.length; i++) {

			if (variable.name == this.state[i].name) {
				found = true;
			}
		}

		if (!found) {
			this.state.push(clone.variable(variable));
		}
	}
}

// Stack data type that is used when the generator
// detects a usage of a function.
function ParenthesisStack (Svariable) {

	this.count = 0
	this.set = 0;
	this.functionName = new Array();
	this.content = new Array();

	this.pushData = function(data) {
		if (this.content.length == 0) {
			throw "Invalid Operation";
		}

		this.content[this.content.length - 1].data.push(data);
	}
}

// Keeps in track of a stack content of a parenthesis stack.
function StackContent () {

	this.data = [];
	this.result = "";
}

// The representation of a line of code
function Line (Lline, Ltoks, Lval, LtokIDs) {

    this.length = Ltoks.length;
	this.lineNumber = Lline;
	this.tokens = Ltoks;
	this.values = Lval;
	this.id = LtokIDs;

	this.actionStack = [];
	this.contentStack = [];
}

// Is used by the generator for languages
// that allows a way to group a set of variables
// and functions (classes or structs)
function Structure (Sname, Scontent) {

	this.name = Sname;
	this.content = Scontent;
}

// Function representation
function Func (Fname, Fparam, Ftype, Fcontent) {

	this.name = Fname;
	this.param = Fparam;
	this.type = Ftype;
	this.content = Fcontent;
}


// Temporary Variable State Object used by
// generator.generateCode()'s tmpVariableStack
// variable
function tmpVariableState (TrefactorIndex) {

    this.referenceIndex  = TrefactorIndex;
}

// Definition Holder Object used by
// generator.generateCode()'s definitionStack
// variable
function tmpDefinitionState (TfuncName, TfuncArgs, TfuncIndention, TfuncLines, Ttype, Tvariables) {

	var _variables = null;
	if (typeof(Tvariables) === "undefined") {
		_variables = new Array();
	}
	else {
		_variables = Tvariables;
	}

    this.name = TfuncName;
    this.arguments = TfuncArgs;
    this.indention = TfuncIndention; // Used for determining indention level
                                     // in order to know if a particular statement
                                     // still belongs to a function/loop/structure
                                     // in python
    this.contains  = TfuncLines;
    this.definitionType = Ttype;
    this.variables = _variables;
}

// Parsed Data that that is consolidated
// to a single object.
function ParseData (Pmap, Psymbol) {

	this.map = Pmap;
	this.symbol = Psymbol;
}

//////////////////////////////////////////////////////////////////////////
// Generator class														//
//////////////////////////////////////////////////////////////////////////
/*																		/*
	Is the class that is responsible for s2sc's code generation, it uses
	the results that was given out by the tokenizer (for identifying
	which set of words matches a specific token type), parser (for
	knowing the objective of a statement) and dictionary (which holds
	information about the list of functions that is possibily used by
	a programming language.
/************************************************************************/
var generator = {

	// Namespace that holds the static keywords of a
	// language, this is done to make it as verbose as possible.
	enums: {

		definition: {

			function: "function"
		},

		c: {

			data: {

				type: {

					integer: "int",
					float: "float",
					bool: "bool",
					string: "string",
					object: "object",
					void: 0
				}
			},

			symbol: {

				string: "char *"
			},

			action: {

				return: {

					undefined: "returnUndefined",
					string: "returnString",
					constant: "returnConst",
				},
			},
		},

		error: {

			parse: "<parse_error>"
		},

		python: {

			data: {

				type: {

					integer: "int",
					float: "float",
					bool: "bool",
					string: "string",
					object: "object",
					void: 0
				}
			},

			symbol: {

				string: "str",
				exponent: "**",
				floorDivision: "//"
			}
		},


		action: {

			basic: {

				constant: "const",
				stringConstant: "sConst",
				result: "result",
				id: "id",
				increment: "incr",
				boolean: "boolStmt",
			},

			return: {

				void: "returnUndefined",
				constant: "returnConst",
				string: "returnString"
			},

            declaration: "decl",
            functionDefinition: "funcDef",
            stringDeclaration: "strDecl",
            compoundAssignment: "cmpAsgn",
            booleanDeclaration: "boolDecl",
        },

        shared: {

			c_python: {

				return: "return",
			}
        },

        symbol: {

			add: "+",
			subtract: "-",
			multiply: "*",
			divide: "/",
			dot: ".",
			comma: ",",
			equal: "=",
			leftParenthesis: "(",
			rightParenthesis: ")",
			lessThan: "<",
			greaterThan: ">",
			true: "True",
			false: "False",

        },

		token: {

			keyword: "kwd",
			identifier: "id",
			symbol: "symb",
			constant: "const",
			reserveWord: "res",
			stringConstant: "sConst",
			tab: "tab",
		}


	},

	// Namespace that holds functions related to including specific built in function,
	// data types and even the necessary modules (headers, sub-classes) that is needed
	// to be imported by a function.
	includer: {

		dataType: {

			ambigious: function() {

				generator.headers.insert("stdbool.h");
				generator.unions.insert("ambigious", "\tbool *boolValue;\n\tint *intValue;\n\tfloat *floatValue;\n\tdouble *doubleValue;\n\tchar *charValue;\n\tvoid *voidValue;\n");
			}
		},

		function: {

			parser: {

				float: {

					string: function() {

						generator.headers.insert("stdio.h");

						if (generator.options.useDoubleInsteadOfFloat) {
							generator.functions.insert("toDouble_str",
								"\tdouble variable = 0;\n\tsscanf(str, \"%d\", &variable);\n\treturn variable;\n",
								"double", "const char *str"
							);
						}
						else {
							generator.functions.insert("toFloat_str",
								"\tfloat variable = 0;\n\tsscanf(str, \"%d\", &variable);\n\treturn variable;\n",
								"float", "const char *str"
							);
						}
					}
				},

				integer: {

					string: function() {

						generator.headers.insert("stdio.h");
						generator.functions.insert("toInteger_str",
							"\tint variable = 0;\n\tsscanf(str, \"%d\", &variable);\n\treturn variable;\n",
							"int", "const char *str"
						);
					}
				},

				string: {

					integer: function() {

						generator.headers.insert("stdio.h");
						generator.headers.insert("stdlib.h");
						generator.headers.insert("gc.h");
						generator.defines.insert("malloc(n)", "GC_MALLOC(n)");
						generator.defines.insert("calloc(m,n)", "GC_MALLOC(m*n)");
						generator.defines.insert("free(p)", "GC_FREE(p)");
						generator.defines.insert("realloc(n)", "GC_REALLOC(n)");
						generator.functions.insert("toString_int",
							"\tchar *buffer = (char*)calloc(2048, sizeof(char));\n\tsprintf(buffer, \"%d\", num);\n\treturn buffer;\n",
							"char *", "int num"
						);
					},

					float: function() {

						generator.headers.insert("stdio.h");
						generator.headers.insert("stdlib.h");
						generator.headers.insert("gc.h");
						generator.defines.insert("malloc(n)", "GC_MALLOC(n)");
						generator.defines.insert("calloc(m,n)", "GC_MALLOC(m*n)");
						generator.defines.insert("free(p)", "GC_FREE(p)");
						generator.defines.insert("realloc(n)", "GC_REALLOC(n)");
						if (generator.options.useDoubleInsteadOfFloat) {
							generator.functions.insert("toString_double",
								"\tchar *buffer = (char*)calloc(2048, sizeof(char));\n\tsprintf(buffer, \"%f\", num);\n\treturn buffer;\n",
								"char *", "double num"
							);
						}
						else {
							generator.functions.insert("toString_float",
								"\tchar *buffer = (char*)calloc(2048, sizeof(char));\n\tsprintf(buffer, \"%f\", num);\n\treturn buffer;\n",
								"char *", "float num"
							);

						}
					},

					concatenator: function() {

						generator.headers.insert("stdio.h");
						generator.headers.insert("stdlib.h");
						generator.headers.insert("stdarg.h");
						generator.headers.insert("string.h");
						generator.headers.insert("gc.h");
						generator.defines.insert("malloc(n)", "GC_MALLOC(n)");
						generator.defines.insert("calloc(m,n)", "GC_MALLOC(m*n)");
						generator.defines.insert("free(p)", "GC_FREE(p)");
						generator.defines.insert("realloc(n)", "GC_REALLOC(n)");
						generator.functions.insert("strConcat",
							"\tchar *buffer = (char*)calloc(2048, sizeof(char));\n\tstrcpy(buffer, \"\");\n\n\tva_list vl;\n\tva_start(vl, limit);\n\tfor (int i = 0; i < limit; i++) {\n\t\tstrcat(buffer, va_arg(vl, char*));\n\t}\n\tva_end(vl);\n\treturn buffer;\n",
							"char *", "int limit, ..."
						);
					}
				}
			},

			math: {

				pow: function() {
					generator.headers.insert("tgmath.h");
				}
			}
		}
	},

	// Namespace that contains the global variables used by s2sc
	variables: {

		comment : '/*******************************************************\n\
\t\tCode generated by s2sc.js\n\
*******************************************************/\n\n',
		defineString: "",
		headerString : "",
		struct: "",
		union: "",
		functions: "",
		bodyBegin : "int main (void) {\n\n",
		bodyEnd   : "\treturn 0;\n}",
	},

	// C related name aliasing
	defines: {

		list: Array(),

		insert: function(name, content) {

			var found = false;
			var struct = new Structure(name, content);
			for (var i = 0; i < generator.defines.list.length; i++) {

				if (generator.defines.list[i].name == struct.name) {
					found = true;
				}
			}

			if (!found) {
				generator.defines.list.push(struct);
			}
		},

		clear: function() {

			generator.variables.defineString = "";
			generator.defines.list = new Array();
		}
	},

	// Holds the list of headers during code generation
	headers: {

		list: Array(),

		insert: function(value) {

			var found = false;
			for (var i = 0; i < generator.headers.list.length; i++) {

				if (generator.headers.list[i] == value) {
					found = true;
				}
			}

			if (!found) {
				generator.headers.list.push(value);
			}
		},

		clear: function() {

			generator.variables.headerString = "";
			generator.headers.list = new Array();
		}
	},

	// Holds the list of C related structures during code generation
	structures: {

		list: Array(),
		insert: function(name, content) {

			var found = false;
			var struct = new Structure(name, content);
			for (var i = 0; i < generator.structures.list.length; i++) {

				if (generator.structures.list[i].name == struct.name) {
					found = true;
				}
			}

			if (!found) {
				generator.structures.list.push(struct);
			}
		},
		clear: function() {

			generator.variables.struct = "";
			generator.structures.list = new Array();
		}
	},

	// Holds the list of C related union during code generation
	unions: {

		list: Array(),
		insert: function(name, content) {

			var found = false;
			var struct = new Structure(name, content);
			for (var i = 0; i < generator.unions.list.length; i++) {

				if (generator.unions.list[i].name == struct.name) {
					found = true;
				}
			}

			if (!found) {
				generator.unions.list.push(struct);
			}
		},

		clear: function() {

			generator.variables.union = "";
			generator.unions.list = new Array();
		}
	},

	// Holds the list of C related functions during code generation
	functions: {

		list: Array(),
		insert: function(name, content, type, parameter) {

			var found = false;
			var struct = new Func(name, parameter, type, content);
			for (var i = 0; i < generator.functions.list.length; i++) {

				if (generator.functions.list[i].name == struct.name) {
					found = true;
				}
			}

			if (!found) {
				generator.functions.list.push(struct);
			}
		},
		clear: function() {

			generator.variables.functions = "";
			generator.functions.list = new Array();
		}
	},

	// Namespaces that holds about code refactoring related materials
	refactor:{

		variableList: [],

		findVariable: function (name, debug) {

			if (typeof(debug) === "undefined") {
				debug = false;
			}

			for (var i = 0; i < generator.refactor.variableList.length; i++) {

				if (debug) {
					alert(generator.refactor.variableList[i].name + " ===" + name);
				}

				if (generator.refactor.variableList[i].name == name) {
					return i;
				}
			}

			return -1;
		},

		getVariable: function (name) {

			var index = generator.refactor.findVariable(name);
			if (index != -1) {

				return generator.refactor.variableList[index];
			}

			throw "Not found variable(" + name + ") on refactor list";
		},

		insertVariable: function (variable) {

			var found = generator.refactor.findVariable(variable.name);
			if (found == -1) {

				generator.refactor.variableList.push(variable);
			}
		},

		removeVariable: function (name) {

			var index = generator.refactor.findVariable(name);
			if (index != -1) {
				generator.refactor.variableList.splice(index, 1);
			}
		},

		clear: function () {

			generator.refactor.variableList = new Array();
		},

	},

	c: {

		to: {

			python: {

				refactor: function (variable, buffer) {

					if (generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type === 0 && generator.refactor.variableList[generator.refactor.findVariable(variable.name)].temporary) {

						variable.type = generator.enums.c.data.type.integer;
						generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type = generator.enums.c.data.type.integer;
						generator.refactor.variableList[generator.refactor.findVariable(variable.name)] = true;
					}

					if (variable.ambigious == false) {

						var foundDeclarationLine = false;
						try {
							if (variable.type != generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type) {

								for (var i = 0; i < buffer.length; i++) {

									var tmpVariableHolder = null;
									var foundDecl =  null;

									for (var j = 0; j < buffer[i].actionStack.length; j++) {

										for (var k = 0; k < buffer[i].actionStack[j].state.length; k++) {

											if (buffer[i].actionStack[j].state[k].name == variable.name) {
												tmpVariableHolder = clone.variable(buffer[i].actionStack[j].state[k]);
												foundDecl = buffer[i].actionStack[j].type;
											}
										}
									}

									if (foundDeclarationLine == false && tmpVariableHolder != null) {

										for (var j = 0; j < buffer[i].values.length; j++) {

											if (buffer[i].values[j] == variable.name) {

												var content = "";
												var allocContent = "";
												foundDeclarationLine = true;

												if (tmpVariableHolder.type == generator.enums.c.data.type.string) {
													buffer[i].contentStack.shift();
												}
												else {
													buffer[i].contentStack[0] = buffer[i].contentStack[0].replace(tmpVariableHolder.type + " ", "");
												}

												if (tmpVariableHolder.type == generator.enums.c.data.type.string) {

													content += tmpVariableHolder.name + ".charValue";
													allocContent = "( char * ) calloc(2048, sizeof( char ) )";
												}
												else {

													content += tmpVariableHolder.name + "." + tmpVariableHolder.type + "Value";
													allocContent = "( " + tmpVariableHolder.type + " * ) calloc(1, sizeof( " + tmpVariableHolder.type + " ) )";
												}

												for (var k = 0; k < buffer[i].tokens.length; k++) {

													if (buffer[i].tokens[k] == generator.enums.token.stringConstant) {
														buffer[i].contentStack[0] = buffer[i].contentStack[0].replace(buffer[i].values[k], buffer[i].id[k]);
													}
												}

												buffer[i].contentStack[0] = buffer[i].contentStack[0].replace(RegExp('\\b' + tmpVariableHolder.name + '\\b','g'), "(*" + content + ")");

												for (var k = 0; k < buffer[i].tokens.length; k++) {

													if (buffer[i].tokens[k] == generator.enums.token.stringConstant) {
														buffer[i].contentStack[0] = buffer[i].contentStack[0].replace(buffer[i].id[k], buffer[i].values[k]);
													}
												}

												buffer[i].contentStack.unshift(content + " = " + allocContent);
												buffer[i].contentStack.unshift("ambigious " + variable.name);
												continue;
											}
										}
									}
									else if (tmpVariableHolder != null) {

										for (var j = 0; j < buffer[i].contentStack.length; j++) {

											var content = "";
											var currentLine = buffer[i].contentStack[j];

											if (tmpVariableHolder.type == generator.enums.c.data.type.string) {

												content += tmpVariableHolder.name + ".charValue";
											}
											else {

												content += "(*" + tmpVariableHolder.name + "." + tmpVariableHolder.type + "Value)";
											}

											for (var k = 0; k < buffer[i].tokens.length; k++) {

												if (buffer[i].tokens[k] == generator.enums.token.stringConstant) {
													currentLine = currentLine.replace(buffer[i].values[k], buffer[i].id[k]);
												}
											}

											currentLine = currentLine.replace(RegExp('\\b' + tmpVariableHolder.name + '\\b','g'), content);

											for (var k = 0; k < buffer[i].tokens.length; k++) {

												if (buffer[i].tokens[k] == generator.enums.token.stringConstant) {
													currentLine = currentLine.replace(buffer[i].id[k], buffer[i].values[k]);
												}
											}

											buffer[i].contentStack[j] = currentLine;
										}
									}
								}

								variable.ambigious = true;
								generator.includer.dataType.ambigious();
							}
						}
						catch (exception) {

							exception.message = variable.name + " is undefined";
							throw exception;
						}
					}
				},

				processBasicStatement: function (line, action, legal, definitionStack, currentLanguage, targetLanguage) {

					line = clone.line(line);
					var isStr = action.type == generator.enums.action.basic.stringConstant || action.type == generator.enums.action.return.string ? true : false;
					var contentBuffer = [];
					var lastContent = "";
					var typeCasted = false;
					var numericVariables = 0;
					var checkStack = new ParenthesisStack();
					var resultingDataType = 0;
					var compoundVariableDataType = 0;
					var parameterSeparated = false;
					var override = false;
					var hasReturnType = false;


					for (var j = 0; j < line.tokens.length; j++) {

						if (parameterSeparated) {

							if (typeCasted) {
								override = true;
							}
							typeCasted = true;
							isStr = false;
						}

						if (line.tokens[j] == generator.enums.token.identifier) {

							try {

								var tmpVariable =
									generator.refactor.getVariable(line.values[j]);

								if (action.type == generator.enums.action.compoundAssignment &&
									compoundVariableDataType == 0) {
									compoundVariableDataType = tmpVariable.type;
								}

								if (resultingDataType == 0 ||
									resultingDataType != generator.enums.c.data.type.float &&
									resultingDataType != generator.enums.c.data.type.bool) {
									resultingDataType = tmpVariable.type;
								}

								action.pushVariableState(tmpVariable);
								if (tmpVariable.type == generator.enums.c.data.type.integer ||
									tmpVariable.type == generator.enums.c.data.type.float ) {

									if (!typeCasted) {
										numericVariables += 1;
									}
								}
								else if (tmpVariable.type == generator.enums.c.data.type.bool) {

								}
								else {


									if (tmpVariable.type == 0) {
										tmpVariable.type = generator.enums.c.data.type.integer;
									}
									else if (!typeCasted) {

										isStr = true;
									}
								}
							}
							catch (exception) {

								legal = false;
							}
						}
						else if (line.tokens[j] == generator.enums.token.constant) {

							try {
								if (resultingDataType != generator.enums.c.data.type.float &&
									resultingDataType != generator.enums.c.data.type.bool) {

									resultingDataType = isEquation(line.values[j]);
								}
							}
							catch (exception) {
								alert(exception + " " + line.values + " " + j + " " + line.tokens);
								legal = false;
							}

							if (!typeCasted && isStr) {
								numericVariables += 1;
							}
						}
						else if (line.tokens[j] == generator.enums.token.reserveWord) {

							if (line.values[j] == generator.enums.c.data.type.integer ||
								line.values[j] == generator.enums.c.data.type.float ||
								line.values[j] == generator.enums.python.symbol.string) {

								typeCasted = true;
								if (line.values[j] == generator.enums.python.symbol.string) {
									isStr = true;
									resultingDataType = generator.enums.c.data.type.string;
								}
							}
							else if (line.values[j] == generator.enums.symbol.true ||
									 line.values[j] == generator.enums.symbol.false) {

								if (!typeCasted) {
									resultingDataType = generator.enums.c.data.type.bool;
								}
							}
						}
						else if (line.tokens[j] == generator.enums.token.keyword) {

							var funcType = dictionary.pages.findWord(line.values[j], currentLanguage).returnType;

							if (funcType == generator.enums.c.data.type.void) {

								legal = false;
							}
							else if (funcType == generator.enums.c.data.type.string && !typeCasted) {
								isStr = true;
								resultingDataType = generator.enums.c.data.type.string;
							}
							else if (funcType == generator.enums.c.data.type.integer ||
									funcType == generator.enums.c.data.type.float) {

								if (!typeCasted && isStr) {
									numericVariables++;
								}
							}

						}
						else if (line.tokens[j] == generator.enums.token.symbol) {

							if (line.values[j] == generator.enums.symbol.leftParenthesis) {

								if (typeCasted) {
									checkStack.set++;
								}
							}
							else if (line.values[j] == generator.enums.symbol.rightParenthesis) {

								if (checkStack.set > 0) {
									checkStack.set--;
								}

								if (checkStack.count == 0) {
									typeCasted = false;
								}

								if (checkStack.set == 0 && checkStack.count > 0) {
									checkStack.count--;
								}
							}
							else if (line.values[j] == generator.enums.symbol.comma && !parameterSeparated) {

								parameterSeparated = true;
								continue;
							}
						}
						else if (line.tokens[j] == generator.enums.token.stringConstant) {

							isStr = true;
							if (resultingDataType == 0 || !typeCasted) {
								resultingDataType = generator.enums.c.data.type.string;
							}
						}

						if (parameterSeparated) {

							if (!override) {
								typeCasted = false;
							}
							override = false;
							parameterSeparated = false;
						}
					}

					if (resultingDataType != compoundVariableDataType &&
						action.type == generator.enums.action.compoundAssignment) {

						if ((
							 resultingDataType != generator.enums.c.data.type.integer &&
							 resultingDataType != generator.enums.c.data.type.float &&
							 resultingDataType != generator.enums.c.data.type.bool
							) ||
							(
							 compoundVariableDataType != generator.enums.c.data.type.integer &&
							 compoundVariableDataType != generator.enums.c.data.type.float &&
							 compoundVariableDataType != generator.enums.c.data.type.bool
							)) {

							legal = false;
						}
					}

					if (isStr && numericVariables > 0) {
						//alert(line.values + " -> " + isStr + ", " + numericVariables);
						legal = false;
					}

					if (!isStr && legal) {

						var exponent = false;
						var floor = false;
						var stack = new ParenthesisStack();
						line.actionStack.push(action);

						for (var j = 0; j < line.tokens.length; j++) {

							lastContent = contentBuffer.slice();

							if (line.tokens[j] == generator.enums.token.constant) {

								try {

									var constantValue = "";
									if (!isInteger(line.values[j])) {
										if (generator.options.useDoubleInsteadOfFloat) {
											constantValue += line.values[j];
										}
										else {
											constantValue += line.values[j] + "f";
										}
									}
									else {
										constantValue += line.values[j];
									}

									if (exponent) {
										exponent = false;
										var prevValue = "";
										if (stack.count > 0) {
											prevValue = stack.content[stack.content.length - 1].data.pop();
										}
										else {
											prevValue = contentBuffer.pop();
										}
										var parameter = [prevValue, ",", constantValue];
										var list = dictionary.pages.findWordsByKeywords(["math-operation", "exponent", "C-language"]);
										var candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
										contentBuffer.push(candidate.function(parameter));
									}
									else if (floor) {
										floor = false;
									}
									else {
										contentBuffer.push(constantValue);
									}

								}
								catch (exception) {

									legal = false;
								}
							}
							else if (line.tokens[j] == generator.enums.token.identifier) {

								var identifier = null;
								for (var k = 0; k < line.actionStack.length; k++) {

									for (var l = 0; l < line.actionStack[k].state.length; l++) {

										if (line.values[j] == line.actionStack[k].state[l].name) {

											identifier = line.actionStack[k].state[l];
											break;
										}
									}
								}

								if (identifier != null) {


									if (identifier.ambigious) {
										if (identifier.type == generator.enums.c.data.type.string) {
											contentBuffer.push(identifier.name + ".charValue");
										}
										else {
											contentBuffer.push("(*" + identifier.name+ "." + identifier.type + "Value)");
										}

									}
									else {
										contentBuffer.push(identifier.name);
									}
								}
							}
							else if (line.tokens[j] == generator.enums.token.reserveWord) {

								if (line.values[j] == generator.enums.c.data.type.integer ||
									line.values[j] == generator.enums.python.data.type.float ||
									line.values[j] == generator.enums.python.symbol.string) {
									if (j + 1 != line.tokens.length) {
										if (line.values[j + 1] == generator.enums.symbol.leftParenthesis) {
											stack.count += 1;
											stack.functionName.push(line.values[j]);
											stack.content.push(new StackContent());
										}
									}
								}
								else if (line.values[j] == generator.enums.symbol.true ||
										 line.values[j] == generator.enums.symbol.false) {
										contentBuffer.push(line.values[j].toLowerCase());
								}
								else if (line.values[j] == generator.enums.shared.c_python.return){

									if (definitionStack.length > 0 ) {
										hasReturnType = true;
										contentBuffer.push(line.values[j]);
									}
									else {

										legal = false;
									}
								}
							}
							else if (line.tokens[j] == generator.enums.token.stringConstant) {

								contentBuffer.push(line.values[j]);
							}
							else if (line.tokens[j] == generator.enums.token.symbol) {

								var pushToBuffer = false;

								if (line.values[j] == generator.enums.symbol.leftParenthesis) {

									if (stack.count > 0) {
										if (!((line.values[j - 1] == generator.enums.c.data.type.integer ||
											line.values[j - 1] == generator.enums.python.data.type.float ||
											line.values[j - 1] == generator.enums.python.symbol.string) ||
											line.tokens[j - 1] == generator.enums.token.keyword)) {
											pushToBuffer = true;
											stack.set++;
										}
									}
									else {
										pushToBuffer = true;
									}
								}
								else if (line.values[j] == generator.enums.symbol.rightParenthesis) {

									if (stack.set > 0) {
										stack.set--;
									}

									if (stack.count == 0) {
										pushToBuffer = true;
									}

									if (stack.set == 0 && stack.count > 0) {

										stack.count--;
										var currentFunction = stack.functionName.pop();
										var currentContentBuffer = stack.content.pop();

										var tmpEquation = currentContentBuffer.data.slice();

										for (var k = 0; k < tmpEquation.length; k++) {

											if (tmpEquation[k].search("intValue") != -1) {

												tmpEquation[k] = tmpEquation[k].substring(1).replace(RegExp('\\b' + ".intValue" + '\\b','g'), "");
											}
											else if (tmpEquation[k].search("intValue") != -1) {
												tmpEquation[k] = tmpEquation[k].substring(1).replace(RegExp('\\b' + ".floatValue" + '\\b','g'), "");
											}
											else if (tmpEquation[k].search("charValue") != -1) {
												tmpEquation[k] = tmpEquation[k].replace(RegExp('\\b' + ".charValue" + '\\b','g'), "");
											}
										}

										var operationType = isEquation(tmpEquation.join(" "));
										//alert(operationType + "-" + currentFunction + " = " + currentContentBuffer.data.join(" "));
										if (operationType == generator.enums.c.data.type.string) {

											var list;
											var candidate;
											var result = "";

											if (currentFunction == generator.enums.c.data.type.integer) {

												if (currentContentBuffer.data.length > 1) {
													//alert(currentContentBuffer.data.join(","));
													for (var k = 0; k < currentContentBuffer.data.length; k++) {
														if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
															currentContentBuffer.data.splice(k, 1);
															k--;
														}
													}

													list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
													result = candidate.function(currentContentBuffer.data);

													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.integer, 3);
													result = candidate.function(result);
												}
												else {
													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.integer, 3);
													result = candidate.function(currentContentBuffer.data);
												}
											}
											else if (currentFunction == generator.enums.python.data.type.float) {

												if (currentContentBuffer.data.length > 1) {

													for (var k = 0; k < currentContentBuffer.data.length; k++) {
														if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
															currentContentBuffer.data.splice(k, 1);
															k--;
														}
													}

													list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
													result = candidate.function(currentContentBuffer.data);

													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
													result = candidate.function(result);
												}
												else {
													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
													result = candidate.function(currentContentBuffer.data);
												}

											}
											else if (currentFunction == generator.enums.python.symbol.string) {

												for (var k = 0; k < currentContentBuffer.data.length; k++) {
													if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
														currentContentBuffer.data.splice(k, 1);
														k--;
													}
												}

												list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data);
											}
											else {
												// Function Analyser here
												try {

													var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
													result = candidate.function(currentContentBuffer.data);

												}
												catch (exception) {

												}
											}
										}
										else if (operationType == generator.enums.c.data.type.integer) {

											var list;
											var candidate;
											var result = "";

											if (currentFunction == generator.enums.c.data.type.integer) {
												result = currentContentBuffer.data.join(" ");
											}
											else if (currentFunction == generator.enums.python.data.type.float) {
												result = "((" + generator.enums.c.data.type.float + ")(" + currentContentBuffer.data.join(" ") + "))";
											}
											else if (currentFunction == generator.enums.python.symbol.string) {
												list = dictionary.pages.findWordsByKeywords(["integer-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data.join(" "));
											}
											else {
												//alert(currentContentBuffer.data.join("-"));
												try {

													var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
													result = candidate.function(currentContentBuffer.data);

												}
												catch (exception) {

												}
											}
										}
										else if (operationType == generator.enums.c.data.type.float) {

											var list;
											var candidate;
											var result = "";
											if (currentFunction == generator.enums.c.data.type.integer) {
												result = "((" + generator.enums.c.data.type.integer + ")(" + currentContentBuffer.data.join(" ") + "))";
											}
											else if (currentFunction == generator.enums.symbol.float) {
												result = currentContentBuffer.data.join(" ");
											}
											else if (currentFunction == generator.enums.python.symbol.string) {

												list = dictionary.pages.findWordsByKeywords(["float-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data.join(" "));
											}
											else {
												// Function Analyser here
												try {

													var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
													result = candidate.function(currentContentBuffer.data);

												}
												catch (exception) {

												}
											}
										}
										else {
											try {

												var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
												result = candidate.function(currentContentBuffer.data);

											}
											catch (exception) {

											}
										}

										if (stack.content.length == 0) {
											currentContentBuffer.result += result;
											contentBuffer.push(currentContentBuffer.result);
										}
										else {

											stack.content[stack.content.length - 1].data.push(result);
										}
									}

								}
								else if (line.values[j] == generator.enums.python.symbol.exponent) {
									exponent = true;
								}
								else if (line.values[j] == generator.enums.python.symbol.floorDivision) {
									floor = true;
								}
								else {
									pushToBuffer = true;
								}

								if (pushToBuffer) {
									contentBuffer.push(line.values[j]);
								}
							}
							else if (line.tokens[j] == generator.enums.token.keyword) {
								if (j + 1 != line.tokens.length) {
									if (line.values[j + 1] == generator.enums.symbol.leftParenthesis) {
										stack.count += 1;
										stack.functionName.push(line.values[j]);
										stack.content.push(new StackContent());
									}
								}
							}

							if (stack.count > 0) {

								for (var k = lastContent.length; k < contentBuffer.length; k++) {

									stack.pushData(contentBuffer[k]);
								}

								contentBuffer = lastContent;
							}
						}
						//
						var content = "";
						for (var j = 0; j < contentBuffer.length; j++) {
							content += trimString(contentBuffer[j]);
							if (j + 1 < contentBuffer.length) {
								content += " ";
							}
						}

						line.contentStack.push(content);

					}

					if (isStr && legal) {

						var exponent = false;
						var floor = false;
						var stack = new ParenthesisStack();
						line.actionStack.push(action);
						var lastContent = "";
						contentBuffer = [];

						for (var j = 0; j < line.tokens.length; j++) {

							lastContent = contentBuffer.slice();

							if (line.tokens[j] == generator.enums.token.constant) {
								try {

									var constantValue = "";
									if (!isInteger(line.values[j])) {
										if (generator.options.useDoubleInsteadOfFloat) {
											constantValue += line.values[j];
										}
										else {
											constantValue += line.values[j] + "f";
										}
									}
									else {
										constantValue += line.values[j];
									}

									if (exponent) {
										exponent = false;
										var prevValue = "";
										if (stack.count > 0) {
											prevValue = stack.content[stack.content.length - 1].data.pop();
										}
										else {
											prevValue = contentBuffer.pop();
										}
										var parameter = [prevValue, ",", constantValue];
										var list = dictionary.pages.findWordsByKeywords(["math-operation", "exponent", "C-language"]);
										var candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
										contentBuffer.push(candidate.function(parameter));
									}
									else if (floor) {
										floor = false;
									}
									else {
										contentBuffer.push(constantValue);
									}
								}
								catch (exception) {

									legal = false;
								}
							}
							else if (line.tokens[j] == generator.enums.token.identifier) {

								var identifier = null;
								for (var k = 0; k < line.actionStack.length; k++) {

									for (var l = 0; l < line.actionStack[k].state.length; l++) {

										if (line.values[j] == line.actionStack[k].state[l].name) {

											identifier = line.actionStack[k].state[l];
											break;
										}
									}
								}

								if (identifier != null) {

									if (identifier.ambigious) {
										if (identifier.type == generator.enums.c.data.type.string) {
											contentBuffer.push(identifier.name + ".charValue");
										}
										else {
											contentBuffer.push("(*" + identifier.name+ "." + identifier.type + "Value)");
										}
									}
									else {
										contentBuffer.push(identifier.name);
									}
								}

							}
							else if (line.tokens[j] == generator.enums.token.reserveWord) {

								if (line.values[j] == generator.enums.c.data.type.integer ||
									line.values[j] == generator.enums.python.data.type.float ||
									line.values[j] == generator.enums.python.symbol.string) {
									if (j + 1 != line.tokens.length) {
										if (line.values[j + 1] == generator.enums.symbol.leftParenthesis) {
											stack.count += 1;
											stack.functionName.push(line.values[j]);
											stack.content.push(new StackContent());
										}
									}
								}
								else if (line.values[j] == generator.enums.symbol.true ||
										 line.values[j] == generator.enums.symbol.false) {
										contentBuffer.push(line.values[j]);
								}
							}
							else if (line.tokens[j] == generator.enums.token.stringConstant) {

								contentBuffer.push(line.values[j]);
							}
							else if (line.tokens[j] == generator.enums.token.symbol) {

								var pushToBuffer = false;

								if (line.values[j] == generator.enums.symbol.leftParenthesis) {

									if (stack.count > 0) {
										if (!((line.values[j - 1] == generator.enums.c.data.type.integer ||
											line.values[j - 1] == generator.enums.python.data.type.float ||
											line.values[j - 1] == generator.enums.python.symbol.string) ||
											line.tokens[j - 1] == generator.enums.token.keyword)) {
											pushToBuffer = true;
											stack.set++;
										}
									}
									else {
										pushToBuffer = true;
									}
								}
								else if (line.values[j] == generator.enums.symbol.rightParenthesis) {

									if (stack.set > 0) {
										stack.set--;
									}

									if (stack.count == 0) {
										pushToBuffer = true;
									}

									if (stack.set == 0 && stack.count > 0) {

										stack.count--;
										var currentFunction = stack.functionName.pop();
										var currentContentBuffer = stack.content.pop();

										var tmpEquation = currentContentBuffer.data.slice();

										for (var k = 0; k < tmpEquation.length; k++) {

											if (tmpEquation[k].search("intValue") != -1) {

												tmpEquation[k] = tmpEquation[k].substring(1).replace(RegExp('\\b' + ".intValue" + '\\b','g'), "");
											}
											else if (tmpEquation[k].search("intValue") != -1) {
												tmpEquation[k] = tmpEquation[k].substring(1).replace(RegExp('\\b' + ".floatValue" + '\\b','g'), "");
											}
											else if (tmpEquation[k].search("charValue") != -1) {
												tmpEquation[k] = tmpEquation[k].replace(RegExp('\\b' + ".charValue" + '\\b','g'), "");
											}
										}

										var operationType = isEquation(tmpEquation.join(" "));
										//alert(operationType + "-" + currentFunction + " = " + currentContentBuffer.data.join(" "));
										if (operationType == generator.enums.c.data.type.string) {

											var list;
											var candidate;
											var result = "";

											if (currentFunction == generator.enums.c.data.type.integer) {

												if (currentContentBuffer.data.length > 1) {
													//alert(currentContentBuffer.data.join(","));
													for (var k = 0; k < currentContentBuffer.data.length; k++) {
														if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
															currentContentBuffer.data.splice(k, 1);
															k--;
														}
													}

													list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
													result = candidate.function(currentContentBuffer.data);

													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.integer, 3);
													result = candidate.function(result);
												}
												else {
													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.integer, 3);
													result = candidate.function(currentContentBuffer.data);
												}
											}
											else if (currentFunction == generator.enums.python.data.type.float) {

												if (currentContentBuffer.data.length > 1) {

													for (var k = 0; k < currentContentBuffer.data.length; k++) {
														if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
															currentContentBuffer.data.splice(k, 1);
															k--;
														}
													}

													list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
													result = candidate.function(currentContentBuffer.data);

													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
													result = candidate.function(result);
												}
												else {
													list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
													candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
													result = candidate.function(currentContentBuffer.data);
												}

											}
											else if (currentFunction == generator.enums.python.symbol.string) {

												for (var k = 0; k < currentContentBuffer.data.length; k++) {
													if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
														currentContentBuffer.data.splice(k, 1);
														k--;
													}
												}

												list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data);
											}
											else {


												try {

													var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
													result = candidate.function(currentContentBuffer.data);

												}
												catch (exception) {

												}
											}
										}
										else if (operationType == generator.enums.c.data.type.integer) {

											var list;
											var candidate;
											var result = "";

											if (currentFunction == generator.enums.c.data.type.integer) {
												result = currentContentBuffer.data.join(" ");
											}
											else if (currentFunction == generator.enums.python.data.type.float) {
												result = "((" + generator.enums.c.data.type.float + ")(" + currentContentBuffer.data.join(" ") + "))";
											}
											else if (currentFunction == generator.enums.python.symbol.string) {
												list = dictionary.pages.findWordsByKeywords(["integer-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data.join(" "));
											}
											else {
												//alert(currentContentBuffer.data.join("-"));
												try {

													var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
													result = candidate.function(currentContentBuffer.data);

												}
												catch (exception) {

												}
											}
										}
										else if (operationType == generator.enums.c.data.type.float) {

											var list;
											var candidate;
											var result = "";
											if (currentFunction == generator.enums.c.data.type.integer) {
												result = "((" + generator.enums.c.data.type.integer + ")(" + currentContentBuffer.data.join(" ") + "))";
											}
											else if (currentFunction == generator.enums.symbol.float) {
												result = currentContentBuffer.data.join(" ");
											}
											else if (currentFunction == generator.enums.python.symbol.string) {

												list = dictionary.pages.findWordsByKeywords(["float-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data.join(" "));
											}
											else {
												// Function Analyser here
												try {

													var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
													result = candidate.function(currentContentBuffer.data);

												}
												catch (exception) {

												}
											}
										}
										else {
											try {

												var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
												result = candidate.function(currentContentBuffer.data);

											}
											catch (exception) {

											}
										}


										if (stack.content.length == 0) {
											currentContentBuffer.result += result;
											contentBuffer.push(currentContentBuffer.result);;
										}
										else {

											stack.content[stack.content.length - 1].data.push(result);
										}
									}
								}
								else if (line.values[j] == generator.enums.python.symbol.exponent) {
									exponent = true;
								}
								else if (line.values[j] == generator.enums.python.symbol.floorDivision) {
									floor = true;
								}
								else {
									pushToBuffer = true;
								}

								if (pushToBuffer) {
									contentBuffer.push(line.values[j]);
								}
							}
							else if (line.tokens[j] == generator.enums.token.keyword) {

								if (j + 1 != line.tokens.length) {
									if (line.values[j + 1] == generator.enums.symbol.leftParenthesis) {
										stack.count += 1;
										stack.functionName.push(line.values[j]);
										stack.content.push(new StackContent());
									}
								}
							}

							if (stack.count > 0) {

								for (var k = lastContent.length; k < contentBuffer.length; k++) {

									stack.pushData(contentBuffer[k]);
								}

								contentBuffer = lastContent;
							}
						}

						var paramList = [];
						var strBuffer = "";
						var content = "";

						for (var j = 0; j < contentBuffer.length; j++) {


							if (!(contentBuffer[j] == generator.enums.symbol.add || contentBuffer[j] == generator.enums.symbol.equal)) {
								try {

									var arrayList = JSON.parse(contentBuffer[j]);
									if (typeof(arrayList) === generator.enums.c.data.type.object) {

										for (var k = 0; k < arrayList.length; k++) {
											paramList.push(arrayList[k]);
										}
									}
									else {
										paramList.push(contentBuffer[j]);
									}

								}
								catch (exception) {

									paramList.push(contentBuffer[j]);
								}
							}
						}


						//////////////////////////////////////////////////////////////
						//To do: Make the parameters convert data-types when needed.//
						//////////////////////////////////////////////////////////////

						for (var j = 0; j < paramList.length; j++) {

							if (paramList[j].search("intValue") != -1) {
								paramList[j] = paramList[j].substring(1).replace(RegExp('\\b' + ".intValue" + '\\b','g'), "");
							}
							else if (paramList[j].search("intValue") != -1) {
								paramList[j] = paramList[j].substring(1).replace(RegExp('\\b' + ".floatValue" + '\\b','g'), "");
							}
							else if (paramList[j].search("charValue") != -1) {
								paramList[j] = paramList[j].replace(RegExp('\\b' + ".charValue" + '\\b','g'), "");
							}

							try {

								var link = generator.refactor.getVariable(paramList[j]);
								if (link.ambigious) {

									if (link.type == "int") {

										var list = dictionary.pages.findWordsByKeywords(["integer-only", "data-type-conversion", "C-language"]);
										var candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
										paramList[j] = candidate.function("*" + paramList[j] + ".intValue");
									}
									else if (link.type == "float") {

										var list = dictionary.pages.findWordsByKeywords(["float-only", "data-type-conversion", "C-language"]);
										var candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
										paramList[j] = candidate.function("*" + paramList[j] + ".floatValue");
									}
									else if (link.type == "string") {

										paramList[j] = paramList[j] + ".charValue";
									}
								}
								else {

									if (link.type == "int") {

										var list = dictionary.pages.findWordsByKeywords(["integer-only", "data-type-conversion", "C-language"]);
										var candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
										paramList[j] = candidate.function(paramList[j]);
									}
									else if (link.type == "float") {

										var list = dictionary.pages.findWordsByKeywords(["float-only", "data-type-conversion", "C-language"]);
										var candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
										paramList[j] = candidate.function(paramList[j]);
									}
									else if (link.type == "string") {

										//alert("@@@@");
									}
								}
							}
							catch (exception2) {

							}
						}

						var list;
						var candidate;
						var result;

						if (action.type == generator.enums.action.compoundAssignment) {

							result = dictionary.pages.findWord("sprintf", "C-language").function(paramList[0], paramList.slice(0, 1).concat(paramList.slice(2)));
						}
						else {

							if (action.type == generator.enums.action.basic.id || action.type == generator.enums.c.action.return.undefined) {

								result = contentBuffer;
							}
							else {

								list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
								candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
								result = candidate.function(paramList);
							}
						}

						if (action.type == generator.enums.action.return.void ||
							action.type == generator.enums.action.return.constant ||
							action.type == generator.enums.action.return.string) {

							if (definitionStack.length > 0 && definitionStack[definitionStack.length - 1].definitionType == generator.enums.definition.function) {
								hasReturnType = true;
								result = "return " + result;
							}
							else {

								legal = false;
							}
						}
						line.contentStack.push(result);
					}

					if (!legal) {

						if (generator.options.detailedErrors) {
							line.contentStack = [];
							line.contentStack.push("//Invalid Syntax (" + line.values.join(" ") + ")");
						}
					}

					return line;
				}
			},
		},
	},

	// Generates code from a current language to a targetted language
	generateCode: function (currentLanguage, targetLanguage, parseData) {

		var string = "";
		var bodyText = "";
		var result = "";
		var buffer = new Array();
		var hasReturnType = false;

		generator.headers.clear();
		generator.defines.clear();
		generator.refactor.clear();
		generator.unions.clear();
		generator.structures.clear();
		generator.functions.clear();

        // Container of loop and functions
        // as it is scanned by the generator
        // also keeps in track of the temporary
        // variables declared inside them.

		var definitionStack  = [];

		for (var i = 0; i < parseData.symbol.length; i++) {

            var tokens = [], tokensAheadByOne = [];
            var values = [], valuesAheadByOne = [];
            var tokenIDs = [];
            var tabCount = 0, tabCountAheadByOne = -1;

			if (i + 1 != parseData.symbol.length) {

				tokensAheadByOne = tokenizer.detokenize(parseData.map[i + 1]);
				valuesAheadByOne = tokensAheadByOne.slice();
				tabCountAheadByOne = 0;

				for (var j = 0; j < valuesAheadByOne.length; j++) {

					var currentSelector = valuesAheadByOne[j].replace(/\d+/g, '');
					var currentIndex 	= valuesAheadByOne[j].replace(/[^0-9.]/g, '');

					tokens[j] = currentSelector;
					if (currentSelector == generator.enums.token.keyword) {

						valuesAheadByOne[j] = tokenizer.token.keyword[currentIndex - 1].value;
					}
					else if (currentSelector == generator.enums.token.identifier) {

						valuesAheadByOne[j] = tokenizer.token.identifier[currentIndex - 1].value;
					}
					else if (currentSelector == generator.enums.token.symbol) {

						valuesAheadByOne[j] = tokenizer.token.symbol[currentIndex - 1].value;
					}
					else if (currentSelector == generator.enums.token.constant) {

						valuesAheadByOne[j] = tokenizer.token.constant[currentIndex - 1].value;
					}
					else if (currentSelector == generator.enums.token.reserveWord) {

						valuesAheadByOne[j] = tokenizer.token.reserveWord[currentIndex - 1].value;
					}
					else if (currentSelector == generator.enums.token.stringConstant) {

						valuesAheadByOne[j] = "\""
						+ tokenizer.token.string[currentIndex - 1].value + "\"";
					}
					else if (currentSelector == generator.enums.token.tab) {
						valuesAheadByOne[j] = "\t";
						tabCountAheadByOne += 1;
					}
				}
            }

			tokens = tokenizer.detokenize(parseData.map[i]);
			values = tokens.slice();
			tokenIDs = tokens.slice();


            for (var j = 0; j < values.length; j++) {

                var currentSelector = values[j].replace(/\d+/g, '');
                var currentIndex 	= values[j].replace(/[^0-9.]/g, '');

                tokens[j] = currentSelector;
                if (currentSelector == generator.enums.token.keyword) {

                    values[j] = tokenizer.token.keyword[currentIndex - 1].value;
                }
                else if (currentSelector == generator.enums.token.identifier) {

                    values[j] = tokenizer.token.identifier[currentIndex - 1].value;
                }
                else if (currentSelector == generator.enums.token.symbol) {

                    values[j] = tokenizer.token.symbol[currentIndex - 1].value;
                }
                else if (currentSelector == generator.enums.token.constant) {

                    values[j] = tokenizer.token.constant[currentIndex - 1].value;
                }
                else if (currentSelector == generator.enums.token.reserveWord) {

                    values[j] = tokenizer.token.reserveWord[currentIndex - 1].value;
                }
                else if (currentSelector == generator.enums.token.stringConstant) {

                    values[j] = "\""
                    + tokenizer.token.string[currentIndex - 1].value + "\"";
                }
                else if (currentSelector == generator.enums.token.tab) {
                	values[j] = "\t";
                	tabCount += 1;
                }
            }

            var line = new Line(i, tokens.slice(), values, tokenIDs);

			var action = new Action(parseData.symbol[i]);
            var legal = true;

            // Grouped each type of statements into their appropriate actions,
            // this approach will greatly increase the # of LOCs but I think
            // this is the best approach because it consolidates bugs
            if (action.type == generator.enums.action.declaration ||
                action.type == generator.enums.action.stringDeclaration ||
                action.type == generator.enums.action.booleanDeclaration) {

				var isStr =
					action.type == generator.enums.action.stringDeclaration ? true : false;
				var contentBuffer = [];
				var newDeclaration = false;
                var variable = null;
                var initialize = false;
                var typeCasted = false;
				var numericVariables = 0;
				var checkStack = new ParenthesisStack();

				for (var j = 0; j < line.tokens.length; j++) {

					if (line.tokens[j] == generator.enums.token.identifier) {

						try {

							if (!initialize) {

								variable = generator.refactor.findVariable(line.values[j]);
								if (variable == -1) {

									variable = new Variable(line.values[j], 0, i);
									newDeclaration = true;
				                }
				                else {

									variable = clone.variable(generator.refactor.variableList[variable]);
									if (variable.type == 0 && variable.temporary) {

										generator.refactor.variableList.splice(generator.refactor.findVariable(line.values[j]), 1);
										variable = new Variable(line.values[j], 0, i);
										newDeclaration = true;
									}
				                }

				                initialize = true;
				            }
				            else {

				            	var tmpVariable =
									generator.refactor.getVariable(line.values[j]);

								action.pushVariableState(tmpVariable);
								if (tmpVariable.type == generator.enums.c.data.type.integer ||
									tmpVariable.type == generator.enums.c.data.type.float ||
									tmpVariable.type == generator.enums.c.data.type.bool) {

									if (variable.type == 0 ||
										variable.type != generator.enums.c.data.type.float) {
										variable.type = tmpVariable.type;
									}

									if (!typeCasted && isStr) {
										numericVariables += 1;
									}

								}
								else {

									if (!typeCasted) {
										isStr = true;
										if (variable.type == generator.enums.c.data.type.integer ||
                                            variable.type == generator.enums.c.data.type.float ||
                                            variable.type == generator.enums.c.data.type.bool) {

                                            legal = false;
                                        }
                                        else {

                                            variable.type = generator.enums.c.data.type.string;
                                        }
									}
								}
				            }

						}
						catch (exception) {

							legal = false;
						}
					}
					else if (line.tokens[j] == generator.enums.token.constant) {


						if (variable.type == 0 ||
						   (variable.type != generator.enums.c.data.type.float)) {
							try {

								variable.type = isInteger(line.values[j]) ?
									generator.enums.c.data.type.integer :
									generator.enums.c.data.type.float;
							}
							catch (exception) {

								legal = false;
							}
						}
						else {

							try {
								isInteger(line.values[j]);
							}
							catch (exception) {
								legal = false;
							}
						}

						if (!typeCasted && isStr) {
							numericVariables += 1;
						}
					}
					else if (line.tokens[j] == generator.enums.token.stringConstant) {

						if (variable.type == 0 && !typeCasted) {
							variable.type = generator.enums.c.data.type.string;
						}
					}
					else if (line.tokens[j] == generator.enums.token.reserveWord) {

						if (line.values[j] == generator.enums.c.data.type.integer ||
							line.values[j] == generator.enums.c.data.type.float) {

							if (variable.type == 0 ||
								variable.type != generator.enums.c.data.type.float) {

								variable.type = line.values[j]
									== generator.enums.c.data.type.integer ?
									generator.enums.c.data.type.integer :
									generator.enums.c.data.type.float;
							}

							typeCasted = true;
						}
						else if (line.values[j] == generator.enums.python.symbol.string) {

							typeCasted = true;
						}
						else if (line.values[j] == generator.enums.symbol.true ||
								 line.values[j] == generator.enums.symbol.false) {

                            generator.headers.insert("stdbool.h");
                            if (variable.type == 0) {

                                variable.type = generator.enums.c.data.type.bool;
                            }
						}
					}
					else if (line.tokens[j] == generator.enums.token.keyword) {

						var funcType = dictionary.pages.findWord(line.values[j], currentLanguage).returnType;
						if (variable.type == 0 ||
							variable.type != generator.enums.c.data.type.float &&
							variable.type != generator.enums.c.data.type.bool) {

							if (funcType == generator.enums.c.data.type.float ||
								funcType == generator.enums.c.data.type.integer) {

								variable.type = funcType;
								if (!typeCasted && isStr) {
									numericVariables++;
								}
							}
							else {

								if (funcType == generator.enums.c.data.type.void)
									legal = false;
								else if (funcType == generator.enums.c.data.type.string && !typeCasted) {
									isStr = true;
									variable.type = generator.enums.c.data.type.string;
								}
								else if (funcType == generator.enums.c.data.type.integer ||
										 funcType == generator.enums.c.data.type.float) {

									variable.type = variable.type == generator.enums.c.data.type.float ? float : funcType;
									if (!typeCasted && isStr) {
										numericVariables++;
									}
								}
							}
						}
						else {

							if (funcType == generator.enums.c.data.type.void)
								legal = false;
							else if (funcType == generator.enums.c.data.type.string && !typeCasted) {
								isStr = true;
							}
							else if (funcType == generator.enums.c.data.type.integer ||
									 funcType == generator.enums.c.data.type.float) {

								if (!typeCasted && isStr) {
									numericVariables++;
								}
							}
						}
					}
					else if (line.tokens[j] == generator.enums.token.symbol) {

						if (line.values[j] == generator.enums.symbol.leftParenthesis) {

							if (typeCasted) {
								checkStack.set++;
							}
						}
						else if (line.values[j] == generator.enums.symbol.rightParenthesis) {

							if (checkStack.set > 0) {
								checkStack.set--;
							}

							if (checkStack.count == 0) {
								typeCasted = false;
							}

							if (checkStack.set == 0 && checkStack.count > 0) {
								checkStack.count--;
							}
						}
						else if (line.values[j] == generator.enums.python.symbol.exponent) {

							if (variable.type == 0 ||
								variable.type != generator.enums.c.data.type.float) {

								variable.type = generator.enums.c.data.type.float;
							}
						}
						else if (line.values[j] == generator.enums.symbol.lessThan ||
								 line.values[j] == generator.enums.symbol.greaterThan) {

                            variable.type = generator.enums.c.data.type.bool;
						}
					}
				}

				//alert(isStr + "  " + numericVariables + "  " + legal);
				if ((isStr && numericVariables > 0) || variable.type == 0) {

					legal = false;
				}
				if (variable.type == generator.enums.c.data.type.bool) {

					generator.headers.insert("stdbool.h");
				}

                if (!isStr && legal) {

					if (newDeclaration) {

						var insideParameter = false;

                        if (definitionStack.length > 0) {

                            variable.temporary = true;
                            var exist = false;

                            for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

								if (definitionStack[definitionStack.length - 1].variables[j] == variable.name) {
									insideParameter = true;
									exist = true;
									break;
								}
                            }

                            if (!exist) {
								definitionStack[definitionStack.length - 1].variables.push(variable.name);
                            }

                        }

						generator.refactor.insertVariable(variable);

						if (!insideParameter)
							contentBuffer.push(variable.type);
					}
					else {

						generator.c.to.python.refactor(variable, buffer);

						if (variable.ambigious) {

							if (generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type != variable.type) {

								var fcontent = "";
								var content = "";
								var allocContent = "";

								if (generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type == generator.enums.c.data.type.string) {

									fcontent += generator.refactor.variableList[generator.refactor.findVariable(variable.name)].name + ".charValue";
								}
								else {

									fcontent += generator.refactor.variableList[generator.refactor.findVariable(variable.name)].name + "." + generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type + "Value";
								}

								if (variable.type == generator.enums.c.data.type.string) {

									allocContent = "( char * ) calloc(2048, sizeof( char ) )";
									content += generator.refactor.variableList[generator.refactor.findVariable(variable.name)].name + ".charValue";
								}
								else {

									allocContent = "( " + variable.type + " * ) calloc(1, sizeof( " + variable.type + " ) )";
									content += variable.name + "." + variable.type + "Value";
								}

								line.contentStack.push("free(" + fcontent + ")");
								line.contentStack.push(content + " = " + allocContent);
							}
						}

						generator.refactor.variableList[generator.refactor.findVariable(variable.name)] = variable;
					}

					action.pushVariableState(variable);
					line.actionStack.push(action);

					// Code Generation Phase

					var exponent = false;
					var floor = false;
					var stack = new ParenthesisStack();
					var lastContent = "";


					for (var j = 0; j < line.tokens.length; j++) {

						lastContent = contentBuffer.slice();

						if (line.tokens[j] == generator.enums.token.constant) {
							try {

								var constantValue = "";
								if (!isInteger(line.values[j])) {
									if (generator.options.useDoubleInsteadOfFloat) {
										constantValue += line.values[j];
									}
									else {
										constantValue += line.values[j] + "f";
									}
								}
								else {
									constantValue += line.values[j];
								}

								if (exponent) {

									exponent = false;
									var prevValue = "";
									if (stack.count > 0) {
										prevValue = stack.content[stack.content.length - 1].data.pop();
									}
									else {
										prevValue = contentBuffer.pop();
									}
									var parameter = [prevValue, ",", constantValue];
									var list = dictionary.pages.findWordsByKeywords(["math-operation", "exponent", "C-language"]);
									var candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
									contentBuffer.push(candidate.function(parameter));
								}
								else if (floor) {
									floor = false;
								}
								else {
									contentBuffer.push(constantValue);
								}

							}
							catch (exception) {

								legal = false;
							}
						}
						else if (line.tokens[j] == generator.enums.token.identifier) {

							var identifier = null;
							for (var k = 0; k < line.actionStack.length; k++) {

								for (var l = 0; l < line.actionStack[k].state.length; l++) {

									if (line.values[j] == line.actionStack[k].state[l].name) {

										identifier = line.actionStack[k].state[l];
										break;
									}
								}
							}

							if (identifier != null) {
								if (identifier.lineDeclared != i && j != 0) {


									if (identifier.type != variable.type && stack.count == 0) {

										if (variable.type == generator.enums.c.data.type.integer ||
											variable.type == generator.enums.c.data.type.float) {
											contentBuffer.push("(" + variable.type + ")");
										}
										else if (identifier.type == generator.enums.c.data.type.string) {

											if (variable.type == generator.enums.c.data.type.integer) {
												generator.includer.function.parser.integer.string();
											}
											else if (variable.type == generator.enums.c.data.type.float) {
												generator.includer.function.parser.float.string();
											}
										}
									}
								}

								if (identifier.ambigious) {
									if (identifier.type == generator.enums.c.data.type.string) {
										contentBuffer.push(identifier.name + ".charValue");
									}
									else {
										contentBuffer.push("(*" + identifier.name+ "." + identifier.type + "Value)");
									}

								}
								else {
									contentBuffer.push(identifier.name);
								}
							}
						}
						else if (line.tokens[j] == generator.enums.token.reserveWord) {

							if (line.values[j] == generator.enums.c.data.type.integer ||
								line.values[j] == generator.enums.python.data.type.float ||
								line.values[j] == generator.enums.python.symbol.string) {

								if (j + 1 != line.tokens.length) {
									if (line.values[j + 1] == generator.enums.symbol.leftParenthesis) {
										stack.count += 1;
										stack.functionName.push(line.values[j]);
										stack.content.push(new StackContent());
									}
								}
							}
							else if (line.values[j] == generator.enums.symbol.true ||
									 line.values[j] == generator.enums.symbol.false) {
									contentBuffer.push(line.values[j].toLowerCase());
							}

						}
						else if (line.tokens[j] == generator.enums.token.stringConstant) {

							contentBuffer.push(line.values[j]);
						}
						else if (line.tokens[j] == generator.enums.token.symbol) {

							var pushToBuffer = false;

							if (line.values[j] == generator.enums.symbol.leftParenthesis) {

								if (stack.count > 0) {
									if (!((line.values[j - 1] == generator.enums.c.data.type.integer ||
										line.values[j - 1] == generator.enums.python.data.type.float ||
										line.values[j - 1] == generator.enums.python.symbol.string) ||
										line.tokens[j - 1] == generator.enums.token.keyword)) {
										pushToBuffer = true;
										stack.set++;
									}
								}
								else {
									pushToBuffer = true;
								}
							}
							else if (line.values[j] == generator.enums.symbol.rightParenthesis) {

								if (stack.set > 0) {
									stack.set--;
								}

								if (stack.count == 0) {
									pushToBuffer = true;
								}

								if (stack.set == 0 && stack.count > 0) {

									stack.count--;
									var currentFunction = stack.functionName.pop();
									var currentContentBuffer = stack.content.pop();

									var tmpEquation = currentContentBuffer.data.slice();

									for (var k = 0; k < tmpEquation.length; k++) {

										if (tmpEquation[k].search("intValue") != -1) {

											tmpEquation[k] = tmpEquation[k].substring(1).replace(RegExp('\\b' + ".intValue" + '\\b','g'), "");
										}
										else if (tmpEquation[k].search("intValue") != -1) {
											tmpEquation[k] = tmpEquation[k].substring(1).replace(RegExp('\\b' + ".floatValue" + '\\b','g'), "");
										}
										else if (tmpEquation[k].search("charValue") != -1) {
											tmpEquation[k] = tmpEquation[k].replace(RegExp('\\b' + ".charValue" + '\\b','g'), "");
										}
									}

									var operationType = isEquation(tmpEquation.join(" "));
									//alert(operationType + "-" + currentFunction + " = " + currentContentBuffer.data.join(" "));
									if (operationType == generator.enums.c.data.type.string) {

										var list;
										var candidate;
										var result = "";

										if (currentFunction == generator.enums.c.data.type.integer) {

											if (currentContentBuffer.data.length > 1) {
												//alert(currentContentBuffer.data.join(","));
												for (var k = 0; k < currentContentBuffer.data.length; k++) {
													if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
														currentContentBuffer.data.splice(k, 1);
														k--;
													}
												}

												list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data);

												list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.integer, 3);
												result = candidate.function(result);
											}
											else {
												list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.integer, 3);
												result = candidate.function(currentContentBuffer.data);
											}
										}
										else if (currentFunction == generator.enums.python.data.type.float) {

											if (currentContentBuffer.data.length > 1) {

												for (var k = 0; k < currentContentBuffer.data.length; k++) {
													if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
														currentContentBuffer.data.splice(k, 1);
														k--;
													}
												}

												list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data);

												list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
												result = candidate.function(result);
											}
											else {
												list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
												result = candidate.function(currentContentBuffer.data);
											}

										}
										else if (currentFunction == generator.enums.python.symbol.string) {

											for (var k = 0; k < currentContentBuffer.data.length; k++) {
												if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
													currentContentBuffer.data.splice(k, 1);
													k--;
												}
											}

											list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
											candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
											result = candidate.function(currentContentBuffer.data);
										}
										else {
											// Function Analyser here
											try {

												var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
												result = candidate.function(currentContentBuffer.data);

											}
											catch (exception) {

											}
										}
									}
									else if (operationType == generator.enums.c.data.type.integer) {

										var list;
										var candidate;
										var result = "";

										if (currentFunction == generator.enums.c.data.type.integer) {
											result = currentContentBuffer.data.join(" ");
										}
										else if (currentFunction == generator.enums.python.data.type.float) {
											result = "((" + generator.enums.c.data.type.float + ")(" + currentContentBuffer.data.join(" ") + "))";
										}
										else if (currentFunction == generator.enums.python.symbol.string) {
											list = dictionary.pages.findWordsByKeywords(["integer-only", "data-type-conversion", "C-language"]);
											candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
											result = candidate.function(currentContentBuffer.data.join(" "));
										}
										else {
											//alert(currentContentBuffer.data.join("-"));
											try {

												var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
												result = candidate.function(currentContentBuffer.data);

											}
											catch (exception) {

											}
										}
									}
									else if (operationType == generator.enums.c.data.type.float) {

										var list;
										var candidate;
										var result = "";
										if (currentFunction == generator.enums.c.data.type.integer) {
											result = "((" + generator.enums.c.data.type.integer + ")(" + currentContentBuffer.data.join(" ") + "))";
										}
										else if (currentFunction == generator.enums.symbol.float) {
											result = currentContentBuffer.data.join(" ");
										}
										else if (currentFunction == generator.enums.python.symbol.string) {

											list = dictionary.pages.findWordsByKeywords(["float-only", "data-type-conversion", "C-language"]);
											candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
											result = candidate.function(currentContentBuffer.data.join(" "));
										}
										else {
											// Function Analyser here
											try {

												var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
												result = candidate.function(currentContentBuffer.data);

											}
											catch (exception) {

											}
										}
									}
									else {
										try {

											var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
											result = candidate.function(currentContentBuffer.data);

										}
										catch (exception) {

										}
									}

									if (stack.content.length == 0) {
										currentContentBuffer.result += result;
										contentBuffer.push(currentContentBuffer.result);
									}
									else {

										stack.content[stack.content.length - 1].data.push(result);
									}
								}

							}
							else if (line.values[j] == generator.enums.python.symbol.exponent) {
								exponent = true;
							}
							else if (line.values[j] == generator.enums.python.symbol.floorDivision) {
								floor = true;
							}
							else {
								pushToBuffer = true;
							}

							if (pushToBuffer) {
								contentBuffer.push(line.values[j]);
							}
						}
						else if (line.tokens[j] == generator.enums.token.keyword) {
							if (j + 1 != line.tokens.length) {
								if (line.values[j + 1] == generator.enums.symbol.leftParenthesis) {
									stack.count += 1;
									stack.functionName.push(line.values[j]);
									stack.content.push(new StackContent());
								}
							}
						}

						if (stack.count > 0) {

							for (var k = lastContent.length; k < contentBuffer.length; k++) {

								stack.pushData(contentBuffer[k]);
							}

							contentBuffer = lastContent;
						}
					}
					//
					var content = "";
					for (var j = 0; j < contentBuffer.length; j++) {
						content += trimString(contentBuffer[j]);
						if (j + 1 < contentBuffer.length) {
							content += " ";
						}
					}
					line.contentStack.push(content);
                }

				/*
					It was necessary to do multiple ifs instead of if and else
					because the first if checks whether the declaration was
					really for  int / float data types by checking the identifiers
					where initialized and are currently holding int / float data
				*/

                if (isStr && legal) {

                    var lastContent = "";
                    contentBuffer = [];
                    var stack = new ParenthesisStack();
					variable.type = generator.enums.c.data.type.string;
					generator.headers.insert("stdio.h");
					generator.headers.insert("stdlib.h");


                    if (newDeclaration) {

						var insideParameter = false;
                        if (definitionStack.length > 0) {

                            variable.temporary = true;
                            var exist = false;

                            for (var j = 0; j < definitionStack[definitionStack.length - 1].variables.length; j++) {

								if (definitionStack[definitionStack.length - 1].variables[j] == variable.name) {
									insideParameter = true;
									exist = true;
									break;
								}
                            }

                            if (!exist) {
								definitionStack[definitionStack.length - 1].variables.push(variable.name);
                            }
                        }

						generator.refactor.insertVariable(variable);

						if (!insideParameter) {

							line.contentStack.push("char *" + variable.name + " = " + " ( char * ) calloc(2048, sizeof( char ))");
						}
					}
					else {

						generator.c.to.python.refactor(variable, buffer);
						if (variable.ambigious) {

							if (generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type != variable.type) {

								var fcontent = "";
								var content = "";
								var allocContent = "";

								if (generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type == generator.enums.c.data.type.string) {

									fcontent += generator.refactor.variableList[generator.refactor.findVariable(variable.name)].name + ".charValue";
								}
								else {

									fcontent += generator.refactor.variableList[generator.refactor.findVariable(variable.name)].name + "." + generator.refactor.variableList[generator.refactor.findVariable(variable.name)].type + "Value";
								}

								if (variable.type == generator.enums.c.data.type.string) {

									allocContent = "( char * ) calloc(2048, sizeof( char ) )";
									content += generator.refactor.variableList[generator.refactor.findVariable(variable.name)].name + ".charValue";
								}
								else {

									allocContent = "( " + variable.type + " * ) calloc(1, sizeof( " + variable.type + " ) )";
									content += "*" + variable.name + "." + variable.type + "Value";
								}

								line.contentStack.push("free(" + fcontent + ")");
								line.contentStack.push(content + " = " + allocContent);
							}
						}

						generator.refactor.variableList[generator.refactor.findVariable(variable.name)] = variable;
					}

					action.pushVariableState(variable);
					line.actionStack.push(action);

					var exponent = false;
					var floor = false;
					var stack = new ParenthesisStack();
					contentBuffer = [];
					var lastContent = "";

					for (var j = 0; j < line.tokens.length; j++) {

						lastContent = contentBuffer.slice();

						if (line.tokens[j] == generator.enums.token.constant) {
							try {

								var constantValue = "";
								if (!isInteger(line.values[j])) {
									if (generator.options.useDoubleInsteadOfFloat) {
										constantValue += line.values[j];
									}
									else {
										constantValue += line.values[j] + "f";
									}
								}
								else {
									constantValue += line.values[j];
								}

								if (exponent) {
									exponent = false;
									var prevValue = "";
									if (stack.count > 0) {
										prevValue = stack.content[stack.content.length - 1].data.pop();
									}
									else {
										prevValue = contentBuffer.pop();
									}
									var parameter = [prevValue, ",", constantValue];
									var list = dictionary.pages.findWordsByKeywords(["math-operation", "exponent", "C-language"]);
									var candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
									contentBuffer.push(candidate.function(parameter));
								}
								else if (floor) {
									floor = false;
								}
								else {
									contentBuffer.push(constantValue);
								}
							}
							catch (exception) {

								legal = false;
							}
						}
						else if (line.tokens[j] == generator.enums.token.identifier) {

							var identifier = null;
							for (var k = 0; k < line.actionStack.length; k++) {

								for (var l = 0; l < line.actionStack[k].state.length; l++) {

									if (line.values[j] == line.actionStack[k].state[l].name) {

										identifier = line.actionStack[k].state[l];
										break;
									}
								}
							}

							if (identifier != null) {

								if (identifier.lineDeclared != i && j != 0) {

									if (identifier.type != variable.type && stack.count == 0) {

										if (variable.type == generator.enums.c.data.type.integer ||
											variable.type == generator.enums.c.data.type.float) {
											contentBuffer.push("(" + variable.type + ")");
										}
										else if (identifier.type == generator.enums.c.data.type.string) {

											if (variable.type == generator.enums.c.data.type.integer) {
												generator.includer.function.parser.integer.string();
											}
											else if (variable.type == generator.enums.c.data.type.float) {
												generator.includer.function.parser.float.string();
											}
										}
									}
								}

								if (identifier.ambigious) {
									if (identifier.type == generator.enums.c.data.type.string) {
										contentBuffer.push(identifier.name + ".charValue");
									}
									else {
										contentBuffer.push("(*" + identifier.name+ "." + identifier.type + "Value)");
									}
								}
								else {
									contentBuffer.push(identifier.name);
								}
							}

						}
						else if (line.tokens[j] == generator.enums.token.reserveWord) {

							if (line.values[j] == generator.enums.c.data.type.integer ||
								line.values[j] == generator.enums.python.data.type.float ||
								line.values[j] == generator.enums.python.symbol.string) {
								if (j + 1 != line.tokens.length) {
									if (line.values[j + 1] == generator.enums.symbol.leftParenthesis) {
										stack.count += 1;
										stack.functionName.push(line.values[j]);
										stack.content.push(new StackContent());
									}
								}
							}
							else if (line.values[j] == generator.enums.symbol.true ||
									 line.values[j] == generator.enums.symbol.false) {
									contentBuffer.push(line.values[j]);
							}
						}
						else if (line.tokens[j] == generator.enums.token.stringConstant) {

							contentBuffer.push(line.values[j]);
						}
						else if (line.tokens[j] == generator.enums.token.symbol) {

							var pushToBuffer = false;

							if (line.values[j] == generator.enums.symbol.leftParenthesis) {

								if (stack.count > 0) {
									if (!((line.values[j - 1] == generator.enums.c.data.type.integer ||
										line.values[j - 1] == generator.enums.python.data.type.float ||
										line.values[j - 1] == generator.enums.python.symbol.string) ||
										line.tokens[j - 1] == generator.enums.token.keyword)) {
										pushToBuffer = true;
										stack.set++;
									}
								}
								else {
									pushToBuffer = true;
								}
							}
							else if (line.values[j] == generator.enums.symbol.rightParenthesis) {

								if (stack.set > 0) {
									stack.set--;
								}

								if (stack.count == 0) {
									pushToBuffer = true;
								}

								if (stack.set == 0 && stack.count > 0) {

									stack.count--;
									var currentFunction = stack.functionName.pop();
									var currentContentBuffer = stack.content.pop();

									var tmpEquation = currentContentBuffer.data.slice();

									for (var k = 0; k < tmpEquation.length; k++) {

										if (tmpEquation[k].search("intValue") != -1) {

											tmpEquation[k] = tmpEquation[k].substring(1).replace(RegExp('\\b' + ".intValue" + '\\b','g'), "");
										}
										else if (tmpEquation[k].search("intValue") != -1) {
											tmpEquation[k] = tmpEquation[k].substring(1).replace(RegExp('\\b' + ".floatValue" + '\\b','g'), "");
										}
										else if (tmpEquation[k].search("charValue") != -1) {
											tmpEquation[k] = tmpEquation[k].replace(RegExp('\\b' + ".charValue" + '\\b','g'), "");
										}
									}

									var operationType = isEquation(tmpEquation.join(" "));
									//alert(operationType + "-" + currentFunction + " = " + currentContentBuffer.data.join(" "));
									if (operationType == generator.enums.c.data.type.string) {

										var list;
										var candidate;
										var result = "";

										if (currentFunction == generator.enums.c.data.type.integer) {

											if (currentContentBuffer.data.length > 1) {
												//alert(currentContentBuffer.data.join(","));
												for (var k = 0; k < currentContentBuffer.data.length; k++) {
													if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
														currentContentBuffer.data.splice(k, 1);
														k--;
													}
												}

												list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data);

												list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.integer, 3);
												result = candidate.function(result);
											}
											else {
												list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.integer, 3);
												result = candidate.function(currentContentBuffer.data);
											}
										}
										else if (currentFunction == generator.enums.python.data.type.float) {

											if (currentContentBuffer.data.length > 1) {

												for (var k = 0; k < currentContentBuffer.data.length; k++) {
													if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
														currentContentBuffer.data.splice(k, 1);
														k--;
													}
												}

												list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
												result = candidate.function(currentContentBuffer.data);

												list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
												result = candidate.function(result);
											}
											else {
												list = dictionary.pages.findWordsByKeywords(["string-only", "data-type-conversion", "C-language"]);
												candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.float, 3);
												result = candidate.function(currentContentBuffer.data);
											}

										}
										else if (currentFunction == generator.enums.python.symbol.string) {

											for (var k = 0; k < currentContentBuffer.data.length; k++) {
												if (currentContentBuffer.data[k] == generator.enums.symbol.add) {
													currentContentBuffer.data.splice(k, 1);
													k--;
												}
											}

											list = dictionary.pages.findWordsByKeywords(["string-only", "concatenation", "C-language"]);
											candidate = dictionary.search.list.byTypeAndCount(list, generator.enums.c.data.type.string, 3);
											result = candidate.function(currentContentBuffer.data);
										}
										else {
											// Function Analyser here
											try {

												var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
												result = candidate.function(currentContentBuffer.data);

											}
											catch (exception) {

											}
										}
									}
									else if (operationType == generator.enums.c.data.type.integer || operationType == generator.enums.c.data.type.float) {

										var list;
										var candidate;
										var result = "";

										if (currentFunction == generator.enums.c.data.type.integer) {
											result = currentContentBuffer.data.join(" ");
										}
										else if (currentFunction == generator.enums.python.data.type.float) {
											result = currentContentBuffer.data.join(" ");
										}
										else if (currentFunction == generator.enums.python.symbol.string) {
											result = currentContentBuffer.data.join(" ");
										}
										else {
											//alert(currentContentBuffer.data.join("-"));
											try {

												var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
												result = candidate.function(currentContentBuffer.data);
											}
											catch (exception) {

											}
										}
									}
									else {
										try {

											var candidate = dictionary.search.equivalentWord(targetLanguage, dictionary.pages.findWord(currentFunction, currentLanguage));
											result = candidate.function(currentContentBuffer.data);

										}
										catch (exception) {

										}
									}


									if (stack.content.length == 0) {
										currentContentBuffer.result += result;
										contentBuffer.push(currentContentBuffer.result);
									}
									else {

										stack.content[stack.content.length - 1].data.push(result);
									}
								}
							}
							else if (line.values[j] == generator.enums.python.symbol.exponent) {
								exponent = true;
							}
							else if (line.values[j] == generator.enums.python.symbol.floorDivision) {
								floor = true;
							}
							else {
								pushToBuffer = true;
							}

							if (pushToBuffer) {
								contentBuffer.push(line.values[j]);
							}
						}
						else if (line.tokens[j] == generator.enums.token.keyword) {

							if (j + 1 != line.tokens.length) {
								if (line.values[j + 1] == generator.enums.symbol.leftParenthesis) {
									stack.count += 1;
									stack.functionName.push(line.values[j]);
									stack.content.push(new StackContent());
								}
							}
						}

						if (stack.count > 0) {

							for (var k = lastContent.length; k < contentBuffer.length; k++) {

								stack.pushData(contentBuffer[k]);
							}

							contentBuffer = lastContent;
						}
					}

					var paramList = [];
					var strBuffer = "";
					var content = "";

					for (var j = 0; j < contentBuffer.length; j++) {

						if (j == 0) {
							strBuffer = contentBuffer[j];
						}
						else {

							if (!(contentBuffer[j] == generator.enums.symbol.add || contentBuffer[j] == generator.enums.symbol.equal)) {
								try {

									var arrayList = JSON.parse(contentBuffer[j]);
									if (typeof(arrayList) === generator.enums.c.data.type.object) {

										for (var k = 0; k < arrayList.length; k++) {
											paramList.push(arrayList[k]);
										}
									}
									else {
										paramList.push(contentBuffer[j]);
									}

								}
								catch (exception) {

									paramList.push(contentBuffer[j]);
								}
							}
						}
					}

					line.contentStack.push(dictionary.pages.findWord("sprintf", "C-language").function(strBuffer, paramList));
					//alert(variable.name + " " + variable.type);
                }

				if (!legal) {

					if (generator.options.detailedErrors) {
						line.contentStack = [];
						line.contentStack.push("//Invalid Syntax (" + line.values.join(" ") + ")");
					}
				}
            }
			else if (action.type == generator.enums.action.basic.constant ||
					 action.type == generator.enums.action.basic.stringConstant ||
					 action.type == generator.enums.action.basic.result ||
					 action.type == generator.enums.action.basic.id ||
					 action.type == generator.enums.action.basic.increment ||
					 action.type == generator.enums.action.compoundAssignment ||
					 action.type == generator.enums.action.basic.boolean ||
					 action.type == generator.enums.action.return.void ||
					 action.type == generator.enums.action.return.constant ||
					 action.type == generator.enums.action.return.string) {

				var line = generator.c.to.python.processBasicStatement(line, action, legal, definitionStack, currentLanguage, targetLanguage);
			}
			else if (action.type == generator.enums.action.functionDefinition) {

                var funcName = "";
                var funcArgs = [];

                for (var j = 0; j < line.tokens.length; j++) {

                    if (line.tokens[j] == generator.enums.token.identifier) {

                        if (funcName == "") {
                            funcName = line.values[j];
                        }
                        else {
                            funcArgs.push(line.values[j]);
                            try {

								var variable = new Variable(line.values[j], 0, 0, false, true);
								generator.refactor.insertVariable(variable);
                            }
                            catch (exception) {

								throw exception;
                            }
                        }
                    }
                    else if (line.tokens[j] == generator.enums.token.keyword) {

						if (funcName == "") {
                            funcName = line.values[j];
                        }
                    }
                }

				if (funcName != "main") {

					definitionStack.push(new tmpDefinitionState(funcName, funcArgs, tabCount, new Array(), generator.enums.definition.function, funcArgs.slice()));
				}
                continue;
			}
			else if (action.type == generator.enums.error.parse) {

				line.contentStack = [];
				line.contentStack.push("//Invalid Syntax (" + line.values.join(" ") + ")");
			}

            var pushToBuffer = true;

            if (definitionStack.length > 0) {

                var lastDefinition = definitionStack[definitionStack.length - 1];
                lastDefinition.contains.push(line);

                if (lastDefinition.indention == tabCountAheadByOne || i + 1 == parseData.symbol.length) {

					var argumentNameList = [];
                    var variableReferences = lastDefinition.variables;
                    var returnType = "void";
                    var parameterString = "";
                    var tabSpace = "";
                    var content = "";

                    for (var j = 0; j < variableReferences.length; j++) {

						var currentArgument = variableReferences[j];
						argumentNameList.push(currentArgument);
                    }

					for (var j = 0; j < lastDefinition.arguments.length; j++) {

						var argVariable = "";
						try {

							argVariable = generator.refactor.getVariable(lastDefinition.arguments[j]);
							if (argVariable.type == 0) {
								argVariable.type = generator.enums.c.data.type.integer;
							}
							var type = argVariable.type == "string" ? "char *" : argVariable.type;
							parameterString += type + " " + argVariable.name;
							if (j + 1 != lastDefinition.arguments.length) {

								parameterString += ", ";
							}

						}
						catch (exception) {

							// Code refactoring when a variable's type isn't defined in a parameter
						}
                    }

					for (var j = 0; j <= lastDefinition.indention; j++) {

						tabSpace += "\t";
					}

                    for (var j = 0; j < lastDefinition.contains.length; j++) {

						for (var k = 0; k < lastDefinition.contains[j].contentStack.length; k++) {

							var symbol = "";
                            for (var l = 0; l < lastDefinition.contains[j].actionStack.length; l++) {
								symbol = lastDefinition.contains[j].actionStack[l].type;
                            }

							if (symbol == generator.enums.c.action.return.undefined || symbol == generator.enums.c.action.return.constant) {
								returnType = isEquation(lastDefinition.contains[j].contentStack[k].replace("return ", ""));
							}

							content += tabSpace + lastDefinition.contains[j].contentStack[k] + ";\n";
						}
                    }

                    if (returnType == generator.enums.c.data.type.string) {
						returnType = generator.enums.c.symbol.string;
                    }

                    /////////////////////////////////////////////////////////////////////////////////

                    for (var j = 0; j < argumentNameList.length; j++) {

						generator.refactor.removeVariable(argumentNameList[j]);
                    }

                    generator.functions.insert(lastDefinition.name, content, returnType, parameterString);
                    tokenizer.python.token.add.keyword(lastDefinition.name);
                    dictionary.pages.addWord(new Word(
						lastDefinition.name, function(value) {

							var parameterString = "";
							var parameterLineBuffer = "";
							for (var i = 0; i < value.length; i++) {

								if (value[i] != generator.enums.symbol.comma) {

									parameterLineBuffer += value[i];
								}

								if (value[i] == generator.enums.symbol.comma || i + 1 == value.length) {

									var paramToken = tokenizer.python.tokenize(parameterLineBuffer)[0];
									var paramMap = tokenizer.detokenize(paramToken);
									var paramValues = paramMap.slice();
									var paramID = paramMap.slice();

									for (var j = 0; j < paramValues.length; j++) {

										var currentSelector = paramValues[j].replace(/\d+/g, '');
										var currentIndex 	= paramValues[j].replace(/[^0-9.]/g, '');

										paramMap[j] = currentSelector;
										if (currentSelector == generator.enums.token.keyword) {

											paramValues[j] = tokenizer.token.keyword[currentIndex - 1].value;
										}
										else if (currentSelector == generator.enums.token.identifier) {

											paramValues[j] = tokenizer.token.identifier[currentIndex - 1].value;
										}
										else if (currentSelector == generator.enums.token.symbol) {

											paramValues[j] = tokenizer.token.symbol[currentIndex - 1].value;
										}
										else if (currentSelector == generator.enums.token.constant) {

											paramValues[j] = tokenizer.token.constant[currentIndex - 1].value;
										}
										else if (currentSelector == generator.enums.token.reserveWord) {

											paramValues[j] = tokenizer.token.reserveWord[currentIndex - 1].value;
										}
										else if (currentSelector == generator.enums.token.stringConstant) {

											paramValues[j] = "\""
											+ tokenizer.token.string[currentIndex - 1].value + "\"";
										}
										else if (currentSelector == generator.enums.token.tab) {
											paramValues[j] = "\t";
										}
									}

									var resultLine = generator.c.to.python.processBasicStatement(new Line(-1, paramMap, paramValues, paramID), new Action(parser.parse(paramToken).symbol), legal, definitionStack, currentLanguage, targetLanguage);

									parameterString += resultLine.contentStack[0];
									if (value[i] == generator.enums.symbol.comma) {
										parameterString += ", ";
									}

									parameterLineBuffer = "";
								}

								if (i + 1 != value.length && value[i + 1] != generator.enums.symbol.comma) {

									parameterLineBuffer += " ";
								}
							}
							return this.name + "(" + parameterString + ")";
						}
					, new Array("integer-only", lastDefinition.name, "C-language"), generator.enums.c.data.type.integer));

                    dictionary.pages.addWord(new Word(
						lastDefinition.name, function(value) {
							return this.name + "(" + value.join(" ") + ")";
						}
					, new Array("integer-only", lastDefinition.name, "Python-language"), generator.enums.python.data.type.integer));
                    definitionStack.pop();
                    generator.reparse = true;
                }


				pushToBuffer = false;
            }

            if (pushToBuffer) {

                buffer.push(line);
            }
		}

		for (var i = 0; i < generator.headers.list.length; i++) {
			generator.variables.headerString += "#include <" + generator.headers.list[i] + ">\n";
		}

		for (var i = 0; i < generator.defines.list.length; i++) {
			generator.variables.defineString += "#define " + generator.defines.list[i].name + " " + generator.defines.list[i].content  +"\n";
		}

		for (var i = 0; i < generator.structures.list.length; i++) {
			generator.variables.struct += "\ntypedef struct {\n" + generator.structure.list[i].content + "} " + generator.structure.list[i].name + ";\n\n";
		}

		for (var i = 0; i < generator.unions.list.length; i++) {
			generator.variables.union += "\ntypedef union {\n" + generator.unions.list[i].content + "} " + generator.unions.list[i].name + ";\n\n";
		}

		for (var i = 0; i < generator.functions.list.length; i++) {
			generator.variables.functions += generator.functions.list[i].type + " " + generator.functions.list[i].name + " (" + generator.functions.list[i].param + ") {\n" + generator.functions.list[i].content + "}\n\n";
		}

		for (var i = 0; i < buffer.length; i++) {
			for (var j = 0; j < buffer[i].contentStack.length; j++) {
				bodyText += "\t" + buffer[i].contentStack[j] + ";\n";
			}
		}

		/*if (hasReturnType) {

			generator.variables.bodyEnd = "}";
		}*/

		result = generator.variables.comment + generator.variables.headerString +
		"\n" + generator.variables.defineString + "\n" + generator.variables.struct + generator.variables.union +
        generator.variables.functions + generator.variables.bodyBegin + bodyText +
		generator.variables.bodyEnd;

		return result;

	},

	// Holds the options to be used during code generation
	options: {

		// Comments out the offending statement that caused the error
		detailedErrors: true,

		// Work only when code is generate to C, will use double instead of float during data type.
		useDoubleInsteadOfFloat: true,
	},

	reparse: false,
}
